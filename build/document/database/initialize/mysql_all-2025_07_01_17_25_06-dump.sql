-- MySQL dump 10.13  Distrib 8.4.5, for Linux (aarch64)
--
-- Host: 127.0.0.1    Database: authorization
-- ------------------------------------------------------
-- Server version	8.4.5

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `authorization`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `authorization` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `authorization`;

--
-- Table structure for table `role`
--

DROP TABLE IF EXISTS `role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `role_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '名称',
  `remark` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='角色';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role`
--

LOCK TABLES `role` WRITE;
/*!40000 ALTER TABLE `role` DISABLE KEYS */;
INSERT INTO `role` (`id`, `role_name`, `remark`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (1,'超级管理员','超级管理员','2019-12-04 11:09:27',1,'超级管理员','2019-12-09 16:59:37',1,'超级管理员',0),(2,'普通用户','普通用户','2019-12-10 17:28:58',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0);
/*!40000 ALTER TABLE `role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role_button`
--

DROP TABLE IF EXISTS `role_button`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role_button` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `role_id` bigint unsigned DEFAULT NULL COMMENT '角色ID',
  `button_id` bigint unsigned DEFAULT NULL COMMENT '按钮ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='角色按钮关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role_button`
--

LOCK TABLES `role_button` WRITE;
/*!40000 ALTER TABLE `role_button` DISABLE KEYS */;
/*!40000 ALTER TABLE `role_button` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role_manager`
--

DROP TABLE IF EXISTS `role_manager`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role_manager` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `role_id` bigint unsigned DEFAULT NULL COMMENT '角色ID',
  `manager_id` bigint unsigned DEFAULT NULL COMMENT '管理员ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='角色管理员关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role_manager`
--

LOCK TABLES `role_manager` WRITE;
/*!40000 ALTER TABLE `role_manager` DISABLE KEYS */;
INSERT INTO `role_manager` (`id`, `role_id`, `manager_id`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (1,1,1,'2019-12-16 22:41:25',1,'超级管理员','2019-12-16 22:41:25',1,'超级管理员',0);
/*!40000 ALTER TABLE `role_manager` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role_menu`
--

DROP TABLE IF EXISTS `role_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role_menu` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `role_id` bigint unsigned DEFAULT NULL COMMENT '角色ID',
  `menu_id` bigint unsigned DEFAULT NULL COMMENT '菜单ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='角色菜单关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role_menu`
--

LOCK TABLES `role_menu` WRITE;
/*!40000 ALTER TABLE `role_menu` DISABLE KEYS */;
INSERT INTO `role_menu` (`id`, `role_id`, `menu_id`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (1,1,100,'2019-12-09 16:59:38',1,'超级管理员','2019-12-09 16:59:38',1,'超级管理员',0),(2,1,101,'2019-12-09 16:59:38',1,'超级管理员','2019-12-09 16:59:38',1,'超级管理员',0),(3,1,10101,'2019-12-09 16:59:38',1,'超级管理员','2019-12-09 16:59:38',1,'超级管理员',0),(4,1,10102,'2019-12-09 16:59:38',1,'超级管理员','2019-12-09 16:59:38',1,'超级管理员',0),(5,1,10103,'2019-12-09 16:59:38',1,'超级管理员','2019-12-09 16:59:38',1,'超级管理员',0),(6,1,10104,'2019-12-10 17:29:53',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0),(7,1,102,'2019-12-09 16:59:38',1,'超级管理员','2019-12-09 16:59:38',1,'超级管理员',0),(8,1,10201,'2019-12-09 16:59:39',1,'超级管理员','2019-12-09 16:59:39',1,'超级管理员',0),(9,1,10202,'2019-12-10 17:29:53',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0),(10,2,100,'2019-12-10 17:29:53',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0),(11,2,102,'2019-12-10 17:29:53',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0),(12,2,10201,'2019-12-10 17:29:53',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0),(13,2,10202,'2019-12-10 17:29:53',1,'超级管理员','2019-12-10 17:29:53',1,'超级管理员',0);
/*!40000 ALTER TABLE `role_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `undo_log`
--

DROP TABLE IF EXISTS `undo_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `undo_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `branch_id` bigint NOT NULL COMMENT '分支事务id',
  `xid` varchar(128) NOT NULL COMMENT '全局事务id',
  `context` varchar(128) NOT NULL COMMENT 'undo_log上下文，例如序列化',
  `rollback_info` longblob NOT NULL COMMENT '回滚信息',
  `log_status` int NOT NULL COMMENT '状态 0:正常的状态,1:防御状态',
  `log_created` datetime(6) NOT NULL COMMENT '创建时间',
  `log_modified` datetime(6) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`),
  KEY `ix_log_created` (`log_created`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='AT事务模式撤销表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `undo_log`
--

LOCK TABLES `undo_log` WRITE;
/*!40000 ALTER TABLE `undo_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `undo_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `builder`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `builder` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `builder`;

--
-- Table structure for table `commonly_version`
--

DROP TABLE IF EXISTS `commonly_version`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `commonly_version` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `manager_id` bigint unsigned DEFAULT NULL COMMENT '管理员ID',
  `jdk_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'JDK版本',
  `spring_cloud_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'SpringCloudVersion',
  `spring_cloud_alibaba_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'SpringCloudAlibabaVersion',
  `spring_boot_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'SpringBootVersion',
  `open_api_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'API文档组件',
  `lombok_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '简化对象lombok',
  `druid_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '数据访问监控Druid',
  `mybatis_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '数据库框架MyBatis版本',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='常用版本';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `commonly_version`
--

LOCK TABLES `commonly_version` WRITE;
/*!40000 ALTER TABLE `commonly_version` DISABLE KEYS */;
/*!40000 ALTER TABLE `commonly_version` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `data_base_file`
--

DROP TABLE IF EXISTS `data_base_file`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `data_base_file` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `project_group_id` bigint unsigned DEFAULT NULL COMMENT '项目群ID',
  `file_url` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '文件地址',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='数据库设计文件';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `data_base_file`
--

LOCK TABLES `data_base_file` WRITE;
/*!40000 ALTER TABLE `data_base_file` DISABLE KEYS */;
/*!40000 ALTER TABLE `data_base_file` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `project`
--

DROP TABLE IF EXISTS `project`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `project` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `project_group_id` bigint unsigned DEFAULT NULL COMMENT '项目群ID',
  `project_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目名称',
  `artifact_id` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '工件ID',
  `package_name` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目包目录',
  `project_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目版本',
  `project_description` varchar(4000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目的描述',
  `project_url` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目访问路径',
  `project_port` varchar(5) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目访问端口',
  `is_service_interface` tinyint unsigned DEFAULT NULL COMMENT '是否Service创建接口;（0.否、1.是）',
  `is_delete_bo` tinyint unsigned DEFAULT NULL COMMENT '是否去除BO层;（0.否、1.是）',
  `is_basis_method` tinyint unsigned DEFAULT NULL COMMENT '是否生成基础方法;（0.否、1.是）',
  `is_redis` tinyint unsigned DEFAULT NULL COMMENT '是否使用Redis缓存;（0.否、1.是）',
  `is_minio` tinyint unsigned DEFAULT NULL COMMENT '是否使用MinIO文件服务器;（0.否、1.是）',
  `is_mail` tinyint unsigned DEFAULT NULL COMMENT '是否使用Mail能力;（0.否、1.是）',
  `is_dispose` tinyint unsigned DEFAULT NULL COMMENT '是否使用内容处理能力;（0.否、1.是）',
  `is_encrypt` tinyint unsigned DEFAULT NULL COMMENT '是否使用加密能力;（0.否、1.是）',
  `is_excel` tinyint unsigned DEFAULT NULL COMMENT '是否使用Excel能力;（0.否、1.是）',
  `druid_url` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'Druid访问路径',
  `druid_account` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'Druid登录账号',
  `druid_password` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'Druid登录密码',
  `is_delete_not_pk` tinyint unsigned DEFAULT NULL COMMENT '是否去除无主键的表;（0.否、1.是）',
  `is_order_key` tinyint unsigned DEFAULT NULL COMMENT '是否吧主键生成时放第一位;（0.否、1.是）',
  `data_base_framework` tinyint unsigned DEFAULT NULL COMMENT '数据层框架类型;（0.不使用数据源、1.JPA、2.Mybatis）',
  `data_base_format` tinyint unsigned DEFAULT NULL COMMENT '数据库格式设定;（0.没有格式转换、1.X_X_Xxxx => XXXXxxx）',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='项目';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `project`
--

LOCK TABLES `project` WRITE;
/*!40000 ALTER TABLE `project` DISABLE KEYS */;
/*!40000 ALTER TABLE `project` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `project_column`
--

DROP TABLE IF EXISTS `project_column`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `project_column` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `project_table_id` bigint unsigned DEFAULT NULL COMMENT '项目表ID',
  `table_schema` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '所属的库',
  `table_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '表名称',
  `column_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '字段名',
  `is_nullable` varchar(5) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '是否可以为空',
  `data_type` varchar(20) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '数据类型;不包括长度',
  `character_maximum_length` int DEFAULT NULL COMMENT '数据长度varchar',
  `numeric_precision` int DEFAULT NULL COMMENT '数字类型的整型部分长度',
  `numeric_scale` int DEFAULT NULL COMMENT '数字类型的小数部分长度',
  `column_type` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '字段类型',
  `column_key` varchar(5) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'PRI为主键，MUL为外键',
  `extra` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '自增标识',
  `column_comment` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '字段注释',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='项目表字段';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `project_column`
--

LOCK TABLES `project_column` WRITE;
/*!40000 ALTER TABLE `project_column` DISABLE KEYS */;
/*!40000 ALTER TABLE `project_column` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `project_group`
--

DROP TABLE IF EXISTS `project_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `project_group` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `manager_id` bigint unsigned DEFAULT NULL COMMENT '管理员ID',
  `project_group_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目群名称',
  `group_id` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '组ID',
  `artifact_id` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '工件ID',
  `version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '项目群版本号',
  `jdk_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'JDK版本',
  `spring_cloud_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'SpringCloudVersion',
  `spring_cloud_alibaba_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'SpringCloudAlibabaVersion',
  `spring_boot_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'SpringBootVersion',
  `open_api_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'API文档组件',
  `lombok_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '简化对象lombok',
  `druid_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '数据访问监控Druid',
  `mybatis_version` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '数据库框架MyBatis版本',
  `remark` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='项目群';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `project_group`
--

LOCK TABLES `project_group` WRITE;
/*!40000 ALTER TABLE `project_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `project_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `project_project_table`
--

DROP TABLE IF EXISTS `project_project_table`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `project_project_table` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `project_id` bigint unsigned DEFAULT NULL COMMENT '项目ID',
  `project_table_id` bigint unsigned DEFAULT NULL COMMENT '项目表ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='项目项目表关系';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `project_project_table`
--

LOCK TABLES `project_project_table` WRITE;
/*!40000 ALTER TABLE `project_project_table` DISABLE KEYS */;
/*!40000 ALTER TABLE `project_project_table` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `project_table`
--

DROP TABLE IF EXISTS `project_table`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `project_table` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `project_group_id` bigint unsigned DEFAULT NULL COMMENT '项目群ID',
  `data_base_file_id` bigint unsigned DEFAULT NULL COMMENT '数据库设计文件ID',
  `table_schema` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '所属的库',
  `table_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '表名称',
  `table_comment` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '表注释',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='项目表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `project_table`
--

LOCK TABLES `project_table` WRITE;
/*!40000 ALTER TABLE `project_table` DISABLE KEYS */;
/*!40000 ALTER TABLE `project_table` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `undo_log`
--

DROP TABLE IF EXISTS `undo_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `undo_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `branch_id` bigint NOT NULL COMMENT '分支事务id',
  `xid` varchar(128) NOT NULL COMMENT '全局事务id',
  `context` varchar(128) NOT NULL COMMENT 'undo_log上下文，例如序列化',
  `rollback_info` longblob NOT NULL COMMENT '回滚信息',
  `log_status` int NOT NULL COMMENT '状态 0:正常的状态,1:防御状态',
  `log_created` datetime(6) NOT NULL COMMENT '创建时间',
  `log_modified` datetime(6) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`),
  KEY `ix_log_created` (`log_created`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='AT事务模式撤销表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `undo_log`
--

LOCK TABLES `undo_log` WRITE;
/*!40000 ALTER TABLE `undo_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `undo_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `capability`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `capability` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `capability`;

--
-- Table structure for table `button`
--

DROP TABLE IF EXISTS `button`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `button` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `button_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '名称',
  `button_sign` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '标识',
  `on_click` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '点击事件',
  `menu_id` bigint unsigned DEFAULT NULL COMMENT '菜单ID',
  `button_order` int DEFAULT NULL COMMENT '排序;按数字从小到大',
  `remark` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='按钮';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `button`
--

LOCK TABLES `button` WRITE;
/*!40000 ALTER TABLE `button` DISABLE KEYS */;
/*!40000 ALTER TABLE `button` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `menu`
--

DROP TABLE IF EXISTS `menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `menu` (
  `id` bigint unsigned NOT NULL COMMENT '主键ID',
  `menu_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '名称',
  `menu_url` varchar(500) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '路径',
  `menu_icon` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜单图标',
  `page_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '页面名称',
  `parent_id` bigint unsigned DEFAULT NULL COMMENT '父级ID',
  `is_turn` tinyint unsigned DEFAULT NULL COMMENT '是否跳转;（0.否、1.是）',
  `is_home` tinyint unsigned DEFAULT NULL COMMENT '是否首页;（0.否、1.是）',
  `menu_order` int DEFAULT NULL COMMENT '排序;按数字从小到大',
  `remark` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='菜单';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `menu`
--

LOCK TABLES `menu` WRITE;
/*!40000 ALTER TABLE `menu` DISABLE KEYS */;
INSERT INTO `menu` (`id`, `menu_name`, `menu_url`, `menu_icon`, `page_name`, `parent_id`, `is_turn`, `is_home`, `menu_order`, `remark`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (100,'首页','/home','icon-home','Home',NULL,1,1,100,'首页','2019-11-29 11:27:59',1,'超级管理员','2019-12-16 16:41:56',1,'超级管理员',0),(101,'系统管理',NULL,'icon-desktop',NULL,NULL,0,0,101,'系统管理操作','2019-11-29 11:27:59',1,'超级管理员','2019-12-16 22:38:03',1,'超级管理员',0),(102,'项目群管理',NULL,'icon-project',NULL,NULL,0,0,102,'项目群操作','2019-11-29 11:27:59',1,'超级管理员','2019-12-16 22:38:03',1,'超级管理员',0),(10101,'菜单管理','/menu/manage','icon-menu','MenuManage',101,1,0,10101,'菜单操作','2019-11-29 11:27:59',1,'超级管理员','2019-12-02 21:50:17',1,'超级管理员',0),(10102,'角色管理','/role/manage','icon-audit','RoleManage',101,1,0,10102,'角色操作','2019-11-29 11:27:59',1,'超级管理员','2019-11-29 11:28:07',1,'超级管理员',0),(10103,'用户管理','/manager/manage','icon-user','ManagerManage',101,1,0,10103,'用户操作','2019-11-29 11:27:59',1,'超级管理员','2019-11-29 11:28:07',1,'超级管理员',0),(10104,'参数管理','/parameter/manage','icon-wrench','ParameterManage',101,1,0,10104,'参数设置操作','2019-11-29 11:27:59',1,'超级管理员','2019-12-16 16:41:56',1,'超级管理员',0),(10201,'项目群管理','/group/manage','icon-project','GroupManage',102,1,0,10201,'项目群操作','2019-11-29 11:27:59',1,'超级管理员','2019-12-19 17:09:48',1,'超级管理员',0),(10202,'新增项目群','/group/detail','icon-file-add','GroupDetail',102,1,0,10202,'新增项目群操作','2019-11-29 11:27:59',1,'超级管理员','2019-12-16 16:41:56',1,'超级管理员',0);
/*!40000 ALTER TABLE `menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `undo_log`
--

DROP TABLE IF EXISTS `undo_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `undo_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `branch_id` bigint NOT NULL COMMENT '分支事务id',
  `xid` varchar(128) NOT NULL COMMENT '全局事务id',
  `context` varchar(128) NOT NULL COMMENT 'undo_log上下文，例如序列化',
  `rollback_info` longblob NOT NULL COMMENT '回滚信息',
  `log_status` int NOT NULL COMMENT '状态 0:正常的状态,1:防御状态',
  `log_created` datetime(6) NOT NULL COMMENT '创建时间',
  `log_modified` datetime(6) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`),
  KEY `ix_log_created` (`log_created`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='AT事务模式撤销表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `undo_log`
--

LOCK TABLES `undo_log` WRITE;
/*!40000 ALTER TABLE `undo_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `undo_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `dictionary`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `dictionary` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `dictionary`;

--
-- Table structure for table `parameter`
--

DROP TABLE IF EXISTS `parameter`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `parameter` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `parameter_code` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '参数代码',
  `parameter_name` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '参数名称',
  `parameter_value` text COLLATE utf8mb4_general_ci COMMENT '参数值',
  `parameter_explain` varchar(4000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '参数说明',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='参数';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `parameter`
--

LOCK TABLES `parameter` WRITE;
/*!40000 ALTER TABLE `parameter` DISABLE KEYS */;
INSERT INTO `parameter` (`id`, `parameter_code`, `parameter_name`, `parameter_value`, `parameter_explain`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (1,'CreateProjectGroupMaxNumber','创建项目群最大数','3','用于限制个人创建项目群最大数量','2019-12-30 09:20:07',1,'超级管理员','2020-01-03 23:25:02',1,'超级管理员',0);
/*!40000 ALTER TABLE `parameter` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `undo_log`
--

DROP TABLE IF EXISTS `undo_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `undo_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `branch_id` bigint NOT NULL COMMENT '分支事务id',
  `xid` varchar(128) NOT NULL COMMENT '全局事务id',
  `context` varchar(128) NOT NULL COMMENT 'undo_log上下文，例如序列化',
  `rollback_info` longblob NOT NULL COMMENT '回滚信息',
  `log_status` int NOT NULL COMMENT '状态 0:正常的状态,1:防御状态',
  `log_created` datetime(6) NOT NULL COMMENT '创建时间',
  `log_modified` datetime(6) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`),
  KEY `ix_log_created` (`log_created`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='AT事务模式撤销表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `undo_log`
--

LOCK TABLES `undo_log` WRITE;
/*!40000 ALTER TABLE `undo_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `undo_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `member`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `member` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `member`;

--
-- Table structure for table `manager`
--

DROP TABLE IF EXISTS `manager`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `manager` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `head_img_url` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '头像',
  `manager_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '姓名',
  `age` tinyint unsigned DEFAULT NULL COMMENT '年龄',
  `sex` tinyint unsigned DEFAULT NULL COMMENT '性别;（0.保密、1.男、2女）',
  `mobile` varchar(20) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '手机号',
  `mail` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '邮箱',
  `account` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '账号',
  `login_password` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '登陆密码',
  `last_attempt_login_request_ip` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '最后尝试请求IP',
  `last_attempt_login_time` datetime DEFAULT NULL COMMENT '最后尝试登陆时间',
  `attempt_login_number` tinyint unsigned DEFAULT NULL COMMENT '尝试登陆次数',
  `request_ip` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '常用请求IP',
  `current_request_ip` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '当前请求IP',
  `remark` varchar(1000) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、1.冻结、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='管理员';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `manager`
--

LOCK TABLES `manager` WRITE;
/*!40000 ALTER TABLE `manager` DISABLE KEYS */;
INSERT INTO `manager` (`id`, `head_img_url`, `manager_name`, `age`, `sex`, `mobile`, `mail`, `account`, `login_password`, `last_attempt_login_request_ip`, `last_attempt_login_time`, `attempt_login_number`, `request_ip`, `current_request_ip`, `remark`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (1,'http://localhost:10000/build/1/user-head-image/346c57e020f043eba9de75e90693b264.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=Fi0jJTQMwab11bPSLaxv%2F20250626%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250626T134935Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=6b3869b1623bcff871270f0232c6bfa7d031319266426b820708e3241122aa08','超级管理员',77,0,'13581876056','fuyongyuan277@sina.cn','admin','c4ca4238a0b923820dcc509a6f75849b','0:0:0:0:0:0:0:1','2025-07-01 09:29:07',0,NULL,'0:0:0:0:0:0:0:1','超级管理员','2019-10-09 17:23:08',1,'超级管理员','2025-07-01 09:29:08',1,'超级管理员',0);
/*!40000 ALTER TABLE `manager` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `undo_log`
--

DROP TABLE IF EXISTS `undo_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `undo_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `branch_id` bigint NOT NULL COMMENT '分支事务id',
  `xid` varchar(128) NOT NULL COMMENT '全局事务id',
  `context` varchar(128) NOT NULL COMMENT 'undo_log上下文，例如序列化',
  `rollback_info` longblob NOT NULL COMMENT '回滚信息',
  `log_status` int NOT NULL COMMENT '状态 0:正常的状态,1:防御状态',
  `log_created` datetime(6) NOT NULL COMMENT '创建时间',
  `log_modified` datetime(6) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`),
  KEY `ix_log_created` (`log_created`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='AT事务模式撤销表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `undo_log`
--

LOCK TABLES `undo_log` WRITE;
/*!40000 ALTER TABLE `undo_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `undo_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `message`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `message` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `message`;

--
-- Table structure for table `notice`
--

DROP TABLE IF EXISTS `notice`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notice` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `notice_title` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '公告标题',
  `notice_content` text COLLATE utf8mb4_general_ci COMMENT '公告内容',
  `notice_author` varchar(200) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '公告作者',
  `notice_order` int DEFAULT NULL COMMENT '公告排序',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `creator_id` bigint unsigned DEFAULT NULL COMMENT '创建人ID',
  `creator_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '创建人名称',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `updater_id` bigint unsigned DEFAULT NULL COMMENT '更新人ID',
  `updater_name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人名称',
  `state` tinyint unsigned DEFAULT NULL COMMENT '状态;（0.正常、99.删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='公告';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notice`
--

LOCK TABLES `notice` WRITE;
/*!40000 ALTER TABLE `notice` DISABLE KEYS */;
INSERT INTO `notice` (`id`, `notice_title`, `notice_content`, `notice_author`, `notice_order`, `create_time`, `creator_id`, `creator_name`, `update_time`, `updater_id`, `updater_name`, `state`) VALUES (1,NULL,NULL,'超级管理员',1,'2019-10-09 17:23:08',1,'超级管理员','2020-04-30 11:10:06',1,'超级管理员',0);
/*!40000 ALTER TABLE `notice` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `undo_log`
--

DROP TABLE IF EXISTS `undo_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `undo_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `branch_id` bigint NOT NULL COMMENT '分支事务id',
  `xid` varchar(128) NOT NULL COMMENT '全局事务id',
  `context` varchar(128) NOT NULL COMMENT 'undo_log上下文，例如序列化',
  `rollback_info` longblob NOT NULL COMMENT '回滚信息',
  `log_status` int NOT NULL COMMENT '状态 0:正常的状态,1:防御状态',
  `log_created` datetime(6) NOT NULL COMMENT '创建时间',
  `log_modified` datetime(6) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`),
  KEY `ix_log_created` (`log_created`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='AT事务模式撤销表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `undo_log`
--

LOCK TABLES `undo_log` WRITE;
/*!40000 ALTER TABLE `undo_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `undo_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `nacos`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `nacos` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `nacos`;

--
-- Table structure for table `config_info`
--

DROP TABLE IF EXISTS `config_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'group_id',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  `c_desc` varchar(256) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'configuration description',
  `c_use` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'configuration usage',
  `effect` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT '配置生效的描述',
  `type` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT '配置的类型',
  `c_schema` text COLLATE utf8mb3_bin COMMENT '配置的模式',
  `encrypted_data_key` varchar(1024) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT '密钥',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_info';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info`
--

LOCK TABLES `config_info` WRITE;
/*!40000 ALTER TABLE `config_info` DISABLE KEYS */;
INSERT INTO `config_info` (`id`, `data_id`, `group_id`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `app_name`, `tenant_id`, `c_desc`, `c_use`, `effect`, `type`, `c_schema`, `encrypted_data_key`) VALUES (5,'authorization-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','b283013226fc255404fcee0daaf427e1','2024-05-13 16:20:34','2025-06-30 02:01:24','fyy','192.168.65.1','authorization','7','鉴权中心基础配置-测试环境','','','yaml','',''),(7,'gateway-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          # 让gateway可以发现nacos中的微服务\n          enabled: true\n      # 全局的跨域处理\n      globalcors:\n        # 解决options请求被拦截问题\n        add-to-simple-url-handler-mapping: true\n        # 跨域配置\n        corsConfigurations:\n          \'[/**]\':\n            # 允许哪些网站的跨域请求\n            allowedOrigins:\n              - \"http://localhost:5173\"\n            # 允许的跨域ajax的请求方式\n            allowedMethods:\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            # 允许在请求中携带的头信息\n            allowedHeaders: \"*\"\n            # 是否允许携带cookie\n            allowCredentials: true\n            # 这次跨域检测的有效期\n            maxAge: 360000\n      # 路由\n      routes:\n        # 路由的名字-唯一\n        - id: build-member-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://member\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/member/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-authorization-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://authorization\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/authorization/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-capability-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://capability\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/capability/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-dictionary-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://dictionary\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/dictionary/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-data-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://data\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/data/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-message-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://message\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/message/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-builder-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://builder\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/builder/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n            \n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'*\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','018ca0bbe805f5d2ca56bb875c23c3ae','2024-05-13 19:31:19','2025-06-30 02:00:56','fyy','192.168.65.1','gateway','7','网关基础配置-测试环境','','','yaml','',''),(10,'jwt-test.yaml','system','# JWT 配置\njwt:\n  # 私钥\n  private-key: |\n    -----BEGIN PRIVATE KEY-----\n    MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDE4+6LTFPezLHIotaJ3Z0nIiDexOnlVJs+zFVs2YVKEj8RZLE91+4FO67lR/C3sQZj8BHTb0UPurDjWFyMt1HmxOty5R5XDgrrsUbBj1Wgn6ue2VzY0mXM0b/y8Kjmj2IaCQh5bzt2+n9YIBJbec7rObSeeipvw4wi5SdTiKRbWgLVmoUOvhoFXVrV9Hfo49S8mTQoBpmeUiO+/rjMew0QGFqARO2+5fWKo/mteHIjHu4J+mI3WDRl7mBaYCsv6EUsBZc/EGfvvEkNeuob+iI0b32rAPTgnHrCOVelPlHwUHr31eRh8Poh/k94cUBh9/U/8jVXzlQJcMFG0Jtc1aUzAgMBAAECggEALResvt9sx/amcvaEXw/P2bIRyCNeFCVD5uaCXAsXYUb7hb7DbxAAldc874sB4PgcqA/H7V4q+Xa+41qN27ZyfgE0kVxTDgoLyz4PH+51ZHOdKSTMBGZvZTDWnsuqSx+kjqTp+XHVsyKcvrCds7CaiLnvGWqORImLE0TbNGDzj24O8Ex4bcjpNa5POGLzco5JlLUJ4HbXf/89c6uS9V8dv2/ev+iRl4JqWFxEc8+0vyFt8rmz36Kf1CImB6D+GWV3Edt7roaHy6zI8A0NV3yz52ROvL/cdCNVljPZWKiOqVF0jrSbc4nlecOB5G9fb3UN2COabqHD2PqKuIUWEvnANQKBgQD8t3a2UsKwOofdO0CHivpvaNcXOpmwPkLVRSDC8QiE7WTaZtsmdXVibqOY1fCkGrpVLWGgwAchPa5prNNQ6o+w9u/7EGiDiBdI+mvoHNSw/eFErj74QJtX5SfZn4K9s8QWx6T9ygQ5+LLtUVyZuTqLiqKnmf4Xfrj/9etqO06vVQKBgQDHcsoodfqg92rrM7MY9a3nEjxx22kklDIKrAcjuto0LVm9n6D/L6ayBLfisgWdzTTDOdAeDE7oy2pI8TGBjFTYIqeXL0qztyP6sjUClZzCJmz2IsposOSzQgO6NDHOCnzJkMi6uSknWubYTuJw1W9aA3hbznCE8sk5uIeueTSyZwKBgErlmLI6XubZwfBoIhzJrKUeHjkNLgVUvnv0i9wakVrL/IrZ1vNT9mEgxy2BolsQbM7Xr0pz/uj0Hd/Fz674hXN+C+uNllv9FmGTji1xdfuqknvHZHQwuZlYGfJeWuIcB+50Zsqsd4oy0dyRs27/vYEjqkcf1XVjIjMB0C5gu1YtAoGAbQE1r4tbYSIYE1f8KEYNt15mHqwV+OHtv5tpg4OZwi6O/24A5bc7WcvuXD2DiE0g6xnrvqBneB/EhP0dW3pA3KeEBMLaBwKu7VL8Wd8+/3VU0+kLys/zDm2j796a4csljFxO+I4+Cb5KsCnc5GIiK4X9/98B7AdtJtjNfvPLcz0CgYBnZROtPfulFSIEXNwL5RMrGgiMBpSMIuXcKcdfGFvhtD9FaDb2j0Ba4GupmWIxPooYN8/XbjRN/E71mipjEEpLxIadJMjsAceR1GVLVEVAfFi3XB5hMZHuJgi6AVcrrCqw2wUPItjkw+X8ur3uRpap6FT4LchTpP2iJK9AgnxIIw==\n    -----END PRIVATE KEY-----\n  # 公钥\n  public-key: |\n    -----BEGIN PUBLIC KEY-----\n    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxOPui0xT3syxyKLWid2dJyIg3sTp5VSbPsxVbNmFShI/EWSxPdfuBTuu5Ufwt7EGY/AR029FD7qw41hcjLdR5sTrcuUeVw4K67FGwY9VoJ+rntlc2NJlzNG/8vCo5o9iGgkIeW87dvp/WCASW3nO6zm0nnoqb8OMIuUnU4ikW1oC1ZqFDr4aBV1a1fR36OPUvJk0KAaZnlIjvv64zHsNEBhagETtvuX1iqP5rXhyIx7uCfpiN1g0Ze5gWmArL+hFLAWXPxBn77xJDXrqG/oiNG99qwD04Jx6wjlXpT5R8FB699XkYfD6If5PeHFAYff1P/I1V85UCXDBRtCbXNWlMwIDAQAB\n    -----END PUBLIC KEY-----\n  # 有效期，单位毫秒秒\n  access-token-expire-time: PT2H\n  # 刷新过期时间\n  refresh-token-expire-time: PT8H\n  # APP刷新过期时间\n  refresh-token-expire-app-time: P30D\n  # JWT存储的请求头\n  token-header: Authorization\n  # JWT负载中拿到开头\n  token-head: Bearer\n  # 签发系统\n  issuer: authorization\n  # 是否输出相关日志\n  show-log: true','d9e1741ec25bd84c88726e6a6901f2dc','2024-06-24 15:06:27','2024-06-26 10:32:43','fyy','192.168.65.1','jwt','7','jwt认证配置-测试环境','','','yaml','',''),(13,'mail-test.yaml','system','#邮箱配置\nspring:\n  mail:\n    host: smtp.sina.cn\n    username: fuyongyuan277@sina.cn\n    password: d0afada3105a3a39\n    properties:\n      personal: \'哎呋歪歪平台\'','2d30a91297693c0d33cb1efe9dc45c82','2024-07-03 14:44:18','2024-07-03 14:44:18','fyy','192.168.65.1','mail','7','mail链接配置-测试环境',NULL,NULL,'yaml',NULL,''),(14,'minio-test.yaml','system','# 文件系统-来源于项目resources下的credentials.json\nminio:\n  # okhttp3 不能直接使用127.0.0.1所以使用localhost\n  url: http://localhost:10000\n  access-key: Fi0jJTQMwab11bPSLaxv\n  secret-key: BdWJcE4HwfTWJmLb73fIzPqY8Y9JA8eXnX57kL50\n  bucket-name: build','ad3d13e33da7963819d9ee130e93eb86','2024-07-03 15:55:48','2025-04-15 09:26:33','fyy','192.168.65.1','minio','7','minio链接配置-测试环境','','','yaml','',''),(15,'authorization-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.authorization.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.authorization.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.authorization.service.impl.*,cn.fyy.authorization.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','9c3e7a21a0918fd366452fd8eb057a32','2024-07-04 14:04:47','2025-06-26 08:05:05','fyy','192.168.65.1','authorization','7','mysql链接配置-测试环境','','','yaml','',''),(16,'redis-test.yaml','system','spring:\n  data:\n    redis:\n      # Redis服务器地址\n      host: 127.0.0.1\n      # Redis服务器连接端口\n      port: 6379\n      # Redis服务器连接密码（默认为空）\n      password: fyyain77\n      # Redis数据库索引（默认为0）\n      database: 0\n      # 连接空闲超过N(s秒、ms毫秒，不加单位时使用毫秒)后关闭，0为禁用，这里配置值和tcp-keepalive值一致\n      timeout: 60s\n      # Lettuce连接池配置\n      lettuce:\n        pool:\n          # 允许最大连接数，默认8（负值表示没有限制），推荐值：大于cpu * 2，通常为(cpu * 2) + 2\n          max-active: 10\n          # 最大空闲连接数，默认8，推荐值：cpu * 2\n          max-idle: 8\n          # 最小空闲连接数，默认0\n          min-idle: 0\n          # 连接用完时，新的请求等待时间(s秒、ms毫秒)，超过该时间抛出异常，默认-1（负值表示没有限制）\n          max-wait: 5s\n','bd96bb87818f8751b249830724cfd221','2024-07-04 15:09:51','2024-07-04 15:09:51','fyy','192.168.65.1','redis','7','redis链接配置-测试环境',NULL,NULL,'yaml',NULL,''),(17,'builder-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 15:20:22','2025-06-30 02:00:09','fyy','192.168.65.1','builder','7','构建模块基础配置-测试环境','','','yaml','',''),(18,'builder-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.builder.repository\'\n    # 数据模型目录\n    dbo-path: cn.fyy.builder.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.builder.service.impl.*,cn.fyy.builder.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','a0965b415ee08a81fefaf21f4e704db9','2024-07-04 15:24:22','2025-06-26 08:05:31','fyy','192.168.65.1','builder','7','mysql链接配置-测试环境','','','yaml','',''),(19,'capability-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 15:44:24','2025-06-30 01:59:50','fyy','192.168.65.1','capability','7','能力模块基础配置-测试环境','','','yaml','',''),(20,'capability-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.capability.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.capability.bean.dbo\'\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.capability.service.impl.*,cn.fyy.capability.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','e0f5d06bb2236e1afdf2566f179d9b80','2024-07-04 15:47:46','2025-06-26 08:05:54','fyy','192.168.65.1','capability','7','mysql链接配置-测试环境','','','yaml','',''),(21,'data-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  servlet:\n    multipart:\n      # 是否启用http上传处理\n      enabled: true\n      # 最大请求文件的大小\n      max-request-size: 100MB\n      # 设置单个文件最大长度\n      max-file-size: 20MB\n      # 当文件达到多少时进行磁盘写入\n      file-size-threshold: 20MB\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','f4e64c8a00b5bb01aa9070234a1a38f8','2024-07-04 15:57:53','2025-06-30 01:59:32','fyy','192.168.65.1','data','7','数据模块基础配置-测试环境','','','yaml','',''),(22,'dictionary-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 16:09:35','2025-06-30 01:59:15','fyy','192.168.65.1','dictionary','7','数据字典模块基础配置-测试环境','','','yaml','',''),(23,'dictionary-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.dictionary.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.dictionary.bean.dbo\'\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.dictionary.service.impl.*,cn.fyy.dictionary.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','e9ff02d687dc4b7468fc20e351ffa7ca','2024-07-04 16:12:37','2025-06-24 12:29:23','fyy','192.168.65.1','dictionary','7','mysql链接配置-测试环境','','','yaml','',''),(24,'member-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','b283013226fc255404fcee0daaf427e1','2024-07-04 16:24:20','2025-06-30 01:59:02','fyy','192.168.65.1','member','7','用户中心基础配置-测试环境','','','yaml','',''),(25,'member-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.member.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.member.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.member.service.impl.*,cn.fyy.member.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','3f5fa9d7c4cbcb40780db3f030dfe6c0','2024-07-04 16:27:07','2025-06-26 08:07:07','fyy','192.168.65.1','member','7','mysql链接配置-测试环境','','','yaml','',''),(26,'message-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 16:40:07','2025-06-30 01:58:38','fyy','192.168.65.1','message','7','消息中心基础配置-测试环境','','','yaml','',''),(27,'message-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.message.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.message.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.message.service.impl.*,cn.fyy.message.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','953d85d6fed256ad5d57fddb16a84c02','2024-07-04 16:41:57','2025-06-26 08:07:36','fyy','192.168.65.1','message','7','mysql链接配置-测试环境','','','yaml','',''),(28,'rocketmq-test.yaml','system','spring:\n  cloud:\n    # 两个 bindings 这种设计是为了分离 行为配置 和 主题绑定配置，使得配置更加清晰和灵活。\n    stream:\n      rocketmq:\n        binder:\n          # RocketMQ NameServer 地址\n          name-server: 127.0.0.1:9876\n        # 定义生产者和消费者的高级行为，-out-0是必须的，-out或-in是生产者或消费者，-0是一个标识\n        bindings:\n          # 生产者\n          share-out-0:\n            producer:\n              # 生产者分组\n              group: share_producer\n          # 消费者\n          share-in-0:\n            consumer:\n              # 消费者消费模式-集群模式\n              messageModel: CLUSTERING\n      # 定义消息通道与 RocketMQ 主题的绑定关系，需要与上方一致\n      bindings:\n        # 生产者\n        share-out-0:\n          # 主题\n          destination: share\n        # 消费者\n        share-in-0:\n          # 主题\n          destination: share\n          # 消费者分组\n          group: share_consumer\n','850f23027398b60ecce44cadc8736be0','2025-04-17 12:04:36','2025-04-28 09:12:02','fyy','192.168.65.1','rocketmq','7','rocketmq链接配置-测试环境','','','yaml','',''),(29,'mongodb-test.yaml','system','spring:\n  # mongodb 配置\n  data:\n    mongodb:\n      host: 127.0.0.1\n      port: 17017\n      username: fyy\n      password: fyyain77\n      database: test','1f096c1b8207b7eeddfef2ec3d112496','2025-05-04 09:12:10','2025-05-04 09:12:10','fyy','192.168.65.1','mongodb','7','rocketmq链接配置-测试环境',NULL,NULL,'yaml',NULL,''),(30,'elasticsearch-test.yaml','system','spring:\n  # elasticsearch 配置\n  elasticsearch:\n    rest:\n      # 根据实际情况修改地址和端口\n      uris: http://127.0.0.1:9200\n      # 用户名\n      username: elastic\n      # 密码\n      password: fyyain77','bc74e63918fd8228d50bc78639392ea6','2025-06-13 02:29:10','2025-06-13 02:30:17','fyy','192.168.65.1','elasticsearch','7','elasticsearch链接配置-测试环境','','','yaml','',''),(31,'seata-server-test.yaml','system','seata:\n  # 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\n  store:\n    mode: db\n    lock:\n      mode: db\n    session:\n      mode: db\n    # 用于密码加密\n    public-key:\n\n    # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n    db:\n      datasource: druid\n      # 数据库类型\n      db-type: mysql\n      # 连接驱动\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      # 数据库地址\n      url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n      # 数据库账号\n      user: root\n      # 数据库密码\n      password: fyyain77\n      min-conn: 5\n      max-conn: 30\n      query-limit: 100\n      max-wait: 5000\n      # 全局事务表\n      global-table: global_table\n      # 分支事务表\n      branch-table: branch_table\n      # 全局事务锁表\n      lock-table: lock_table\n      # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n      distributed-lock-table: distributed_lock','3a579669069e9a77038868057f03302e','2025-06-23 09:36:06','2025-06-24 09:29:10','fyy','192.168.65.1','seata','7','seata服务配置-测试环境','','','yaml','',''),(32,'job-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2025-06-27 12:25:53','2025-06-30 01:58:22','fyy','192.168.65.1','job','7','定时任务执行器基础配置-测试环境','','','yaml','',''),(33,'job-xxl-test.yaml','service','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: log/${spring.application.name}-handler-${spring.profiles.active}\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','6069cc039204971fe79a4dbc1b487589','2025-06-27 12:30:14','2025-06-27 13:15:16','fyy','192.168.65.1','job','7','定时任务执行器xxl链接配置-测试环境','','','yaml','','');
/*!40000 ALTER TABLE `config_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_info_aggr`
--

DROP TABLE IF EXISTS `config_info_aggr`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info_aggr` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `datum_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'datum_id',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT '内容',
  `gmt_modified` datetime NOT NULL COMMENT '修改时间',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='增加租户字段';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info_aggr`
--

LOCK TABLES `config_info_aggr` WRITE;
/*!40000 ALTER TABLE `config_info_aggr` DISABLE KEYS */;
/*!40000 ALTER TABLE `config_info_aggr` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_info_beta`
--

DROP TABLE IF EXISTS `config_info_beta`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info_beta` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `beta_ips` varchar(1024) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'betaIps',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  `encrypted_data_key` varchar(1024) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT '密钥',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_info_beta';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info_beta`
--

LOCK TABLES `config_info_beta` WRITE;
/*!40000 ALTER TABLE `config_info_beta` DISABLE KEYS */;
/*!40000 ALTER TABLE `config_info_beta` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_info_tag`
--

DROP TABLE IF EXISTS `config_info_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_id',
  `tag_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'tag_id',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_info_tag';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info_tag`
--

LOCK TABLES `config_info_tag` WRITE;
/*!40000 ALTER TABLE `config_info_tag` DISABLE KEYS */;
/*!40000 ALTER TABLE `config_info_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_tags_relation`
--

DROP TABLE IF EXISTS `config_tags_relation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_tags_relation` (
  `id` bigint NOT NULL COMMENT 'id',
  `tag_name` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'tag_name',
  `tag_type` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'tag_type',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_id',
  `nid` bigint NOT NULL AUTO_INCREMENT COMMENT 'nid, 自增长标识',
  PRIMARY KEY (`nid`),
  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB AUTO_INCREMENT=146 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_tag_relation';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_tags_relation`
--

LOCK TABLES `config_tags_relation` WRITE;
/*!40000 ALTER TABLE `config_tags_relation` DISABLE KEYS */;
INSERT INTO `config_tags_relation` (`id`, `tag_name`, `tag_type`, `data_id`, `group_id`, `tenant_id`, `nid`) VALUES (10,'认证配置','','jwt-test.yaml','system','7',22),(13,'链接配置','','mail-test.yaml','system','7',26),(16,'链接配置','','redis-test.yaml','system','7',31),(14,'链接配置','','minio-test.yaml','system','7',86),(28,'链接配置','','rocketmq-test.yaml','system','7',114),(29,'链接配置','','mongodb-test.yaml','system','7',115),(30,'链接配置','','elasticsearch-test.yaml','system','7',117),(31,'服务配置','','seata-server-test.yaml','system','7',125),(23,'链接配置','','dictionary-data-test.yaml','service','7',127),(15,'链接配置','','authorization-data-test.yaml','service','7',128),(18,'链接配置','','builder-data-test.yaml','service','7',129),(20,'链接配置','','capability-data-test.yaml','service','7',130),(25,'链接配置','','member-data-test.yaml','service','7',131),(27,'链接配置','','message-data-test.yaml','service','7',132),(33,'链接配置','','job-xxl-test.yaml','service','7',136),(32,'基础配置','','job-base-test.yaml','service','7',137),(26,'基础配置','','message-base-test.yaml','service','7',138),(24,'基础配置','','member-base-test.yaml','service','7',139),(22,'基础配置','','dictionary-base-test.yaml','service','7',140),(21,'基础配置','','data-base-test.yaml','service','7',141),(19,'基础配置','','capability-base-test.yaml','service','7',142),(17,'基础配置','','builder-base-test.yaml','service','7',143),(7,'基础配置','','gateway-base-test.yaml','service','7',144),(5,'基础配置','','authorization-base-test.yaml','service','7',145);
/*!40000 ALTER TABLE `config_tags_relation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `group_capacity`
--

DROP TABLE IF EXISTS `group_capacity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `group_capacity` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群',
  `quota` int unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值',
  `max_aggr_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='集群、各Group容量信息表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `group_capacity`
--

LOCK TABLES `group_capacity` WRITE;
/*!40000 ALTER TABLE `group_capacity` DISABLE KEYS */;
/*!40000 ALTER TABLE `group_capacity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `his_config_info`
--

DROP TABLE IF EXISTS `his_config_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `his_config_info` (
  `id` bigint unsigned NOT NULL COMMENT 'id',
  `nid` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT 'nid, 自增标识',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  `op_type` char(10) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'operation type',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  `encrypted_data_key` varchar(1024) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT '密钥',
  PRIMARY KEY (`nid`),
  KEY `idx_gmt_create` (`gmt_create`),
  KEY `idx_gmt_modified` (`gmt_modified`),
  KEY `idx_did` (`data_id`)
) ENGINE=InnoDB AUTO_INCREMENT=61 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='多租户改造';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `his_config_info`
--

LOCK TABLES `his_config_info` WRITE;
/*!40000 ALTER TABLE `his_config_info` DISABLE KEYS */;
INSERT INTO `his_config_info` (`id`, `nid`, `data_id`, `group_id`, `app_name`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `op_type`, `tenant_id`, `encrypted_data_key`) VALUES (0,31,'elasticsearch-test.yaml','system','elasticsearch','spring:\n  # elasticsearch 配置\n  elasticsearch:\n    rest:\n      # 根据实际情况修改地址和端口\n      uris: http://127.0.0.1:9200\n      # 如果启用了安全认证，请提供用户名\n      username: elastic\n      # 如果启用了安全认证，请提供密码\n      password: fyyain77','56674315d9ee05edd5f9646068d2b4a5','2025-06-13 02:29:10','2025-06-13 10:29:10','fyy','192.168.65.1','I','7',''),(30,32,'elasticsearch-test.yaml','system','elasticsearch','spring:\n  # elasticsearch 配置\n  elasticsearch:\n    rest:\n      # 根据实际情况修改地址和端口\n      uris: http://127.0.0.1:9200\n      # 如果启用了安全认证，请提供用户名\n      username: elastic\n      # 如果启用了安全认证，请提供密码\n      password: fyyain77','56674315d9ee05edd5f9646068d2b4a5','2025-06-13 02:30:16','2025-06-13 10:30:17','fyy','192.168.65.1','U','7',''),(0,33,'seata-server-test.yaml','system','seata','#Used for password encryption\nstore:\n  publicKey:\n','b66b17d7bedc3462f05412724bb207f4','2025-06-23 09:36:06','2025-06-23 17:36:06','fyy','192.168.65.1','I','7',''),(31,34,'seata-server-test.yaml','system','seata','#Used for password encryption\nstore:\n  publicKey:\n','b66b17d7bedc3462f05412724bb207f4','2025-06-23 09:46:16','2025-06-23 17:46:17','fyy','192.168.65.1','U','7',''),(31,35,'seata-server-test.yaml','system','seata','#事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  #用于密码加密\n  publicKey:\n\n  #如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: 123456\n    minConn: 5\n    maxConn: 30\n    globalTable: global_table\n    branchTable: branch_table\n    distributedLockTable: distributed_lock\n    queryLimit: 100\n    lockTable: lock_table\n    maxWait: 5000','759cf58a32a8482c36a8def0b98fed8d','2025-06-23 09:50:04','2025-06-23 17:50:04','fyy','192.168.65.1','U','7',''),(31,36,'seata-server-test.yaml','system','seata','#事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  #用于密码加密\n  publicKey:\n\n  #如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: fyyain77\n    minConn: 5\n    maxConn: 30\n    globalTable: global_table\n    branchTable: branch_table\n    distributedLockTable: distributed_lock\n    queryLimit: 100\n    lockTable: lock_table\n    maxWait: 5000','e9c9e9e735b3b8188e11079ec8600a12','2025-06-23 14:30:02','2025-06-23 22:30:02','fyy','192.168.65.1','U','7',''),(31,37,'seata-server-test.yaml','system','seata','#事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  #用于密码加密\n  publicKey:\n\n  #如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: fyyain77\n    minConn: 5\n    maxConn: 30\n    queryLimit: 100\n    maxWait: 5000\n    # 全局事务表\n    globalTable: global_table\n    # 分支事务表\n    branchTable: branch_table\n    # 全局事务锁表\n    lockTable: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributedLockTable: distributed_lock','89695a79a1c407777e41478b30d01d0e','2025-06-23 14:30:15','2025-06-23 22:30:15','fyy','192.168.65.1','U','7',''),(31,38,'seata-server-test.yaml','system','seata','# 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  # 用于密码加密\n  publicKey:\n\n  # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: fyyain77\n    minConn: 5\n    maxConn: 30\n    queryLimit: 100\n    maxWait: 5000\n    # 全局事务表\n    globalTable: global_table\n    # 分支事务表\n    branchTable: branch_table\n    # 全局事务锁表\n    lockTable: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributedLockTable: distributed_lock','b94053d7a09bab24be47312c8d691113','2025-06-24 07:45:18','2025-06-24 15:45:18','fyy','192.168.65.1','U','7',''),(31,39,'seata-server-test.yaml','system','seata','# 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  # 用于密码加密\n  publicKey:\n\n  # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    # 数据库类型\n    db-type: mysql\n    # 连接驱动\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    # 数据库地址\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    # 数据库账号\n    user: root\n    # 数据库密码\n    password: fyyain77\n    min-conn: 5\n    max-conn: 30\n    query-limit: 100\n    max-wait: 5000\n    # 全局事务表\n    globalTable: global_table\n    # 分支事务表\n    branchTable: branch_table\n    # 全局事务锁表\n    lockTable: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributedLockTable: distributed_lock','8472402753481aa2ef0fd56d90e01aaa','2025-06-24 07:55:40','2025-06-24 15:55:41','fyy','192.168.65.1','U','7',''),(31,40,'seata-server-test.yaml','system','seata','# 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  # 用于密码加密\n  public-key:\n\n  # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    # 数据库类型\n    db-type: mysql\n    # 连接驱动\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    # 数据库地址\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    # 数据库账号\n    user: root\n    # 数据库密码\n    password: fyyain77\n    min-conn: 5\n    max-conn: 30\n    query-limit: 100\n    max-wait: 5000\n    # 全局事务表\n    global-table: global_table\n    # 分支事务表\n    branch-table: branch_table\n    # 全局事务锁表\n    lock-table: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributed-lock-table: distributed_lock','ba18d612a1b63b19d58f8f2f40d7651f','2025-06-24 09:29:09','2025-06-24 17:29:10','fyy','192.168.65.1','U','7',''),(23,41,'dictionary-data-test.yaml','service','dictionary','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.dictionary.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.dictionary.bean.dbo\'\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.dictionary.service.impl.*,cn.fyy.dictionary.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','513f2a222b34197624a1dabd4652855c','2025-06-24 12:28:48','2025-06-24 20:28:48','fyy','192.168.65.1','U','7',''),(23,42,'dictionary-data-test.yaml','service','dictionary','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.dictionary.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.dictionary.bean.dbo\'\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.dictionary.service.impl.*,cn.fyy.dictionary.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','7d92546b87098eed526850536ed87149','2025-06-24 12:29:22','2025-06-24 20:29:23','fyy','192.168.65.1','U','7',''),(15,43,'authorization-data-test.yaml','service','authorization','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.authorization.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.authorization.bean.dbo\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.authorization.service.impl.*,cn.fyy.authorization.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','768fe400852ddf710f330e2f7ebe45b8','2025-06-26 08:05:04','2025-06-26 16:05:05','fyy','192.168.65.1','U','7',''),(18,44,'builder-data-test.yaml','service','builder','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.builder.repository\'\n    # 数据模型目录\n    dbo-path: cn.fyy.builder.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.builder.service.impl.*,cn.fyy.builder.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','8356df9969343ab3f1014fba9eaae164','2025-06-26 08:05:30','2025-06-26 16:05:31','fyy','192.168.65.1','U','7',''),(20,45,'capability-data-test.yaml','service','capability','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.capability.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.capability.bean.dbo\'\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.capability.service.impl.*,cn.fyy.capability.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','367ae7d6612345f71a41d5a49aa10ed9','2025-06-26 08:05:54','2025-06-26 16:05:54','fyy','192.168.65.1','U','7',''),(25,46,'member-data-test.yaml','service','member','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.member.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.member.bean.dbo\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.member.service.impl.*,cn.fyy.member.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','b507ba8e1e18de22b109fd22c42d0211','2025-06-26 08:07:07','2025-06-26 16:07:07','fyy','192.168.65.1','U','7',''),(27,47,'message-data-test.yaml','service','message','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.message.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.message.bean.dbo\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.message.service.impl.*,cn.fyy.message.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','7bdbbc3e83ef4eca438e79f50259bca3','2025-06-26 08:07:35','2025-06-26 16:07:36','fyy','192.168.65.1','U','7',''),(0,48,'job-base-test.yaml','service','job','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-27 12:25:52','2025-06-27 20:25:53','fyy','192.168.65.1','I','7',''),(0,49,'job-xxl-test.yaml','service','job','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: /data/applogs/xxl-job/jobhandler\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','d9c7394e9ee41bca3df3fec8ed2043a2','2025-06-27 12:30:14','2025-06-27 20:30:14','fyy','192.168.65.1','I','7',''),(33,50,'job-xxl-test.yaml','service','job','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: /data/applogs/xxl-job/jobhandler\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','d9c7394e9ee41bca3df3fec8ed2043a2','2025-06-27 13:10:40','2025-06-27 21:10:41','fyy','192.168.65.1','U','7',''),(33,51,'job-xxl-test.yaml','service','job','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: log/${spring.application.name}-job-handler-${spring.profiles.active}\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','873ff87cb36661dacf0015422ab8de8c','2025-06-27 13:15:16','2025-06-27 21:15:16','fyy','192.168.65.1','U','7',''),(32,52,'job-base-test.yaml','service','job','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:58:22','2025-06-30 09:58:22','fyy','192.168.65.1','U','7',''),(26,53,'message-base-test.yaml','service','message','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:58:38','2025-06-30 09:58:38','fyy','192.168.65.1','U','7',''),(24,54,'member-base-test.yaml','service','member','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','2a25dcb649e1498d84d66419a7988eef','2025-06-30 01:59:02','2025-06-30 09:59:02','fyy','192.168.65.1','U','7',''),(22,55,'dictionary-base-test.yaml','service','dictionary','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:59:15','2025-06-30 09:59:15','fyy','192.168.65.1','U','7',''),(21,56,'data-base-test.yaml','service','data','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  servlet:\n    multipart:\n      # 是否启用http上传处理\n      enabled: true\n      # 最大请求文件的大小\n      max-request-size: 100MB\n      # 设置单个文件最大长度\n      max-file-size: 20MB\n      # 当文件达到多少时进行磁盘写入\n      file-size-threshold: 20MB\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','e28c82a3e65f91fda0101099bd6ed902','2025-06-30 01:59:31','2025-06-30 09:59:32','fyy','192.168.65.1','U','7',''),(19,57,'capability-base-test.yaml','service','capability','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:59:49','2025-06-30 09:59:50','fyy','192.168.65.1','U','7',''),(17,58,'builder-base-test.yaml','service','builder','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 02:00:09','2025-06-30 10:00:09','fyy','192.168.65.1','U','7',''),(7,59,'gateway-base-test.yaml','service','gateway','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          # 让gateway可以发现nacos中的微服务\n          enabled: true\n      # 全局的跨域处理\n      globalcors:\n        # 解决options请求被拦截问题\n        add-to-simple-url-handler-mapping: true\n        # 跨域配置\n        corsConfigurations:\n          \'[/**]\':\n            # 允许哪些网站的跨域请求\n            allowedOrigins:\n              - \"http://localhost:5173\"\n            # 允许的跨域ajax的请求方式\n            allowedMethods:\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            # 允许在请求中携带的头信息\n            allowedHeaders: \"*\"\n            # 是否允许携带cookie\n            allowCredentials: true\n            # 这次跨域检测的有效期\n            maxAge: 360000\n      # 路由\n      routes:\n        # 路由的名字-唯一\n        - id: build-member-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://member\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/member/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-authorization-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://authorization\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/authorization/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-capability-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://capability\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/capability/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-dictionary-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://dictionary\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/dictionary/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-data-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://data\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/data/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-message-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://message\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/message/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-builder-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://builder\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/builder/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n            \n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'*\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','a9c133d677900acfddcb1b7ce213ed42','2025-06-30 02:00:55','2025-06-30 10:00:56','fyy','192.168.65.1','U','7',''),(5,60,'authorization-base-test.yaml','service','authorization','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','2a25dcb649e1498d84d66419a7988eef','2025-06-30 02:01:23','2025-06-30 10:01:24','fyy','192.168.65.1','U','7','');
/*!40000 ALTER TABLE `his_config_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `permissions`
--

DROP TABLE IF EXISTS `permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `permissions` (
  `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'role',
  `resource` varchar(128) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'resource',
  `action` varchar(8) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'action',
  UNIQUE KEY `uk_role_permission` (`role`,`resource`,`action`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `permissions`
--

LOCK TABLES `permissions` WRITE;
/*!40000 ALTER TABLE `permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `roles`
--

DROP TABLE IF EXISTS `roles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `roles` (
  `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'username',
  `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'role',
  UNIQUE KEY `idx_user_role` (`username`,`role`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `roles`
--

LOCK TABLES `roles` WRITE;
/*!40000 ALTER TABLE `roles` DISABLE KEYS */;
INSERT INTO `roles` (`username`, `role`) VALUES ('fyy','ROLE_ADMIN');
/*!40000 ALTER TABLE `roles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tenant_capacity`
--

DROP TABLE IF EXISTS `tenant_capacity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tenant_capacity` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT 'Tenant ID',
  `quota` int unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数',
  `max_aggr_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='租户容量信息表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tenant_capacity`
--

LOCK TABLES `tenant_capacity` WRITE;
/*!40000 ALTER TABLE `tenant_capacity` DISABLE KEYS */;
/*!40000 ALTER TABLE `tenant_capacity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tenant_info`
--

DROP TABLE IF EXISTS `tenant_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tenant_info` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `kp` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'kp',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_id',
  `tenant_name` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_name',
  `tenant_desc` varchar(256) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'tenant_desc',
  `create_source` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'create_source',
  `gmt_create` bigint NOT NULL COMMENT '创建时间',
  `gmt_modified` bigint NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='tenant_info';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tenant_info`
--

LOCK TABLES `tenant_info` WRITE;
/*!40000 ALTER TABLE `tenant_info` DISABLE KEYS */;
INSERT INTO `tenant_info` (`id`, `kp`, `tenant_id`, `tenant_name`, `tenant_desc`, `create_source`, `gmt_create`, `gmt_modified`) VALUES (1,'1','7','build','集群','nacos',1715566617280,1720518414000);
/*!40000 ALTER TABLE `tenant_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'username',
  `password` varchar(500) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'password',
  `enabled` tinyint(1) NOT NULL COMMENT 'enabled',
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` (`username`, `password`, `enabled`) VALUES ('fyy','$2a$10$GOIX3LAsojczOiltrInyau2zTAtRnHQALKIY868AkPkC19Aj6Bs4W',1);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `seata`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `seata` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `seata`;

--
-- Table structure for table `branch_table`
--

DROP TABLE IF EXISTS `branch_table`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `branch_table` (
  `branch_id` bigint NOT NULL COMMENT '分支事务ID',
  `xid` varchar(128) NOT NULL COMMENT '全局事务ID',
  `transaction_id` bigint DEFAULT NULL COMMENT '事务ID',
  `resource_group_id` varchar(32) DEFAULT NULL COMMENT '资源组ID',
  `resource_id` varchar(256) DEFAULT NULL COMMENT '资源ID',
  `branch_type` varchar(8) DEFAULT NULL COMMENT '分支类型',
  `status` tinyint DEFAULT NULL COMMENT '状态',
  `client_id` varchar(64) DEFAULT NULL COMMENT '客户端ID',
  `application_data` varchar(2000) DEFAULT NULL COMMENT '应用扩展数据',
  `gmt_create` datetime(6) DEFAULT NULL COMMENT '记录创建时间',
  `gmt_modified` datetime(6) DEFAULT NULL COMMENT '记录最后修改时间',
  PRIMARY KEY (`branch_id`),
  KEY `idx_xid` (`xid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='分支事务表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `branch_table`
--

LOCK TABLES `branch_table` WRITE;
/*!40000 ALTER TABLE `branch_table` DISABLE KEYS */;
/*!40000 ALTER TABLE `branch_table` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `distributed_lock`
--

DROP TABLE IF EXISTS `distributed_lock`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `distributed_lock` (
  `lock_key` char(20) NOT NULL COMMENT '锁键',
  `lock_value` varchar(20) NOT NULL COMMENT '锁值',
  `expire` bigint DEFAULT NULL COMMENT '过期时间',
  PRIMARY KEY (`lock_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='分布式锁表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `distributed_lock`
--

LOCK TABLES `distributed_lock` WRITE;
/*!40000 ALTER TABLE `distributed_lock` DISABLE KEYS */;
INSERT INTO `distributed_lock` (`lock_key`, `lock_value`, `expire`) VALUES ('AsyncCommitting',' ',0),('RetryCommitting',' ',0),('RetryRollbacking',' ',0),('TxTimeoutCheck',' ',0);
/*!40000 ALTER TABLE `distributed_lock` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `global_table`
--

DROP TABLE IF EXISTS `global_table`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `global_table` (
  `xid` varchar(128) NOT NULL COMMENT '全局事务ID',
  `transaction_id` bigint DEFAULT NULL COMMENT '事务ID',
  `status` tinyint NOT NULL COMMENT '状态',
  `application_id` varchar(32) DEFAULT NULL COMMENT '应用ID',
  `transaction_service_group` varchar(32) DEFAULT NULL COMMENT '事务服务组名',
  `transaction_name` varchar(128) DEFAULT NULL COMMENT '事务名称',
  `timeout` int DEFAULT NULL COMMENT '超时时间',
  `begin_time` bigint DEFAULT NULL COMMENT '事务开始时间',
  `application_data` varchar(2000) DEFAULT NULL COMMENT '应用扩展数据',
  `gmt_create` datetime DEFAULT NULL COMMENT '记录创建时间',
  `gmt_modified` datetime DEFAULT NULL COMMENT '记录最后修改时间',
  PRIMARY KEY (`xid`),
  KEY `idx_status_gmt_modified` (`status`,`gmt_modified`),
  KEY `idx_transaction_id` (`transaction_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='全局事务表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `global_table`
--

LOCK TABLES `global_table` WRITE;
/*!40000 ALTER TABLE `global_table` DISABLE KEYS */;
/*!40000 ALTER TABLE `global_table` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lock_table`
--

DROP TABLE IF EXISTS `lock_table`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `lock_table` (
  `row_key` varchar(128) NOT NULL COMMENT '行锁键',
  `xid` varchar(128) DEFAULT NULL COMMENT '全局事务ID',
  `transaction_id` bigint DEFAULT NULL COMMENT '事务ID',
  `branch_id` bigint NOT NULL COMMENT '分支事务ID',
  `resource_id` varchar(256) DEFAULT NULL COMMENT '资源ID',
  `table_name` varchar(32) DEFAULT NULL COMMENT '表名',
  `pk` varchar(36) DEFAULT NULL COMMENT '主键值',
  `status` tinyint NOT NULL DEFAULT '0' COMMENT '状态 0:locked ,1:rollbacking',
  `gmt_create` datetime DEFAULT NULL COMMENT '记录创建时间',
  `gmt_modified` datetime DEFAULT NULL COMMENT '记录最后修改时间',
  PRIMARY KEY (`row_key`),
  KEY `idx_status` (`status`),
  KEY `idx_branch_id` (`branch_id`),
  KEY `idx_xid` (`xid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='锁记录表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lock_table`
--

LOCK TABLES `lock_table` WRITE;
/*!40000 ALTER TABLE `lock_table` DISABLE KEYS */;
/*!40000 ALTER TABLE `lock_table` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `xxl_job`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `xxl_job` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `xxl_job`;

--
-- Table structure for table `xxl_job_group`
--

DROP TABLE IF EXISTS `xxl_job_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_group` (
  `id` int NOT NULL AUTO_INCREMENT,
  `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',
  `title` varchar(12) NOT NULL COMMENT '执行器名称',
  `address_type` tinyint NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',
  `address_list` text COMMENT '执行器地址列表，多地址逗号分隔',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_group`
--

LOCK TABLES `xxl_job_group` WRITE;
/*!40000 ALTER TABLE `xxl_job_group` DISABLE KEYS */;
INSERT INTO `xxl_job_group` (`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (3,'build-xxl-job-executor','build定时任务执行器',0,NULL,'2025-07-01 15:21:51');
/*!40000 ALTER TABLE `xxl_job_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_info`
--

DROP TABLE IF EXISTS `xxl_job_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_info` (
  `id` int NOT NULL AUTO_INCREMENT,
  `job_group` int NOT NULL COMMENT '执行器主键ID',
  `job_desc` varchar(255) NOT NULL,
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',
  `schedule_type` varchar(50) NOT NULL DEFAULT 'NONE' COMMENT '调度类型',
  `schedule_conf` varchar(128) DEFAULT NULL COMMENT '调度配置，值含义取决于调度类型',
  `misfire_strategy` varchar(50) NOT NULL DEFAULT 'DO_NOTHING' COMMENT '调度过期策略',
  `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',
  `executor_timeout` int NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',
  `executor_fail_retry_count` int NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',
  `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',
  `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',
  `trigger_status` tinyint NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',
  `trigger_last_time` bigint NOT NULL DEFAULT '0' COMMENT '上次调度时间',
  `trigger_next_time` bigint NOT NULL DEFAULT '0' COMMENT '下次调度时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_info`
--

LOCK TABLES `xxl_job_info` WRITE;
/*!40000 ALTER TABLE `xxl_job_info` DISABLE KEYS */;
INSERT INTO `xxl_job_info` (`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`, `trigger_status`, `trigger_last_time`, `trigger_next_time`) VALUES (4,3,'简单任务示例','2025-06-27 21:03:09','2025-06-27 21:19:00','fyy','','CRON','* * * * * ?','DO_NOTHING','FIRST','demoJobHandler','','SERIAL_EXECUTION',0,0,'BEAN','','GLUE代码初始化','2025-06-27 21:03:09','',0,0,0),(5,3,'分片广播任务示例','2025-06-27 21:18:34','2025-06-27 21:32:02','fyy','','CRON','* * * * * ?','DO_NOTHING','FIRST','shardingJobHandler','','SERIAL_EXECUTION',0,0,'BEAN','','GLUE代码初始化','2025-06-27 21:18:34','',0,0,0);
/*!40000 ALTER TABLE `xxl_job_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_lock`
--

DROP TABLE IF EXISTS `xxl_job_lock`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_lock` (
  `lock_name` varchar(50) NOT NULL COMMENT '锁名称',
  PRIMARY KEY (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_lock`
--

LOCK TABLES `xxl_job_lock` WRITE;
/*!40000 ALTER TABLE `xxl_job_lock` DISABLE KEYS */;
INSERT INTO `xxl_job_lock` (`lock_name`) VALUES ('schedule_lock');
/*!40000 ALTER TABLE `xxl_job_lock` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_log`
--

DROP TABLE IF EXISTS `xxl_job_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `job_group` int NOT NULL COMMENT '执行器主键ID',
  `job_id` int NOT NULL COMMENT '任务，主键ID',
  `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',
  `executor_fail_retry_count` int NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',
  `trigger_code` int NOT NULL COMMENT '调度-结果',
  `trigger_msg` text COMMENT '调度-日志',
  `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',
  `handle_code` int NOT NULL COMMENT '执行-状态',
  `handle_msg` text COMMENT '执行-日志',
  `alarm_status` tinyint NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',
  PRIMARY KEY (`id`),
  KEY `I_trigger_time` (`trigger_time`),
  KEY `I_handle_code` (`handle_code`),
  KEY `I_jobid_jobgroup` (`job_id`,`job_group`),
  KEY `I_job_id` (`job_id`)
) ENGINE=InnoDB AUTO_INCREMENT=93 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_log`
--

LOCK TABLES `xxl_job_log` WRITE;
/*!40000 ALTER TABLE `xxl_job_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `xxl_job_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_log_report`
--

DROP TABLE IF EXISTS `xxl_job_log_report`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_log_report` (
  `id` int NOT NULL AUTO_INCREMENT,
  `trigger_day` datetime DEFAULT NULL COMMENT '调度-时间',
  `running_count` int NOT NULL DEFAULT '0' COMMENT '运行中-日志数量',
  `suc_count` int NOT NULL DEFAULT '0' COMMENT '执行成功-日志数量',
  `fail_count` int NOT NULL DEFAULT '0' COMMENT '执行失败-日志数量',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_log_report`
--

LOCK TABLES `xxl_job_log_report` WRITE;
/*!40000 ALTER TABLE `xxl_job_log_report` DISABLE KEYS */;
INSERT INTO `xxl_job_log_report` (`id`, `trigger_day`, `running_count`, `suc_count`, `fail_count`, `update_time`) VALUES (1,'2025-06-27 00:00:00',0,0,0,NULL),(2,'2025-06-26 00:00:00',0,0,0,NULL),(3,'2025-06-25 00:00:00',0,0,0,NULL),(4,'2025-06-28 00:00:00',0,0,0,NULL),(5,'2025-06-29 00:00:00',0,0,0,NULL),(6,'2025-06-30 00:00:00',0,0,0,NULL),(7,'2025-07-01 00:00:00',0,0,0,NULL);
/*!40000 ALTER TABLE `xxl_job_log_report` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_logglue`
--

DROP TABLE IF EXISTS `xxl_job_logglue`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_logglue` (
  `id` int NOT NULL AUTO_INCREMENT,
  `job_id` int NOT NULL COMMENT '任务，主键ID',
  `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_logglue`
--

LOCK TABLES `xxl_job_logglue` WRITE;
/*!40000 ALTER TABLE `xxl_job_logglue` DISABLE KEYS */;
/*!40000 ALTER TABLE `xxl_job_logglue` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_registry`
--

DROP TABLE IF EXISTS `xxl_job_registry`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_registry` (
  `id` int NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(50) NOT NULL,
  `registry_key` varchar(255) NOT NULL,
  `registry_value` varchar(255) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=449 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_registry`
--

LOCK TABLES `xxl_job_registry` WRITE;
/*!40000 ALTER TABLE `xxl_job_registry` DISABLE KEYS */;
/*!40000 ALTER TABLE `xxl_job_registry` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `xxl_job_user`
--

DROP TABLE IF EXISTS `xxl_job_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `xxl_job_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '账号',
  `password` varchar(50) NOT NULL COMMENT '密码',
  `role` tinyint NOT NULL COMMENT '角色：0-普通用户、1-管理员',
  `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_username` (`username`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `xxl_job_user`
--

LOCK TABLES `xxl_job_user` WRITE;
/*!40000 ALTER TABLE `xxl_job_user` DISABLE KEYS */;
INSERT INTO `xxl_job_user` (`id`, `username`, `password`, `role`, `permission`) VALUES (1,'admin','15c045b33a7afdead2376c302f12cade',1,NULL);
/*!40000 ALTER TABLE `xxl_job_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-07-01  9:25:06
