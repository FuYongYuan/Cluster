-- MySQL dump 10.13  Distrib 8.4.5, for Linux (aarch64)
--
-- Host: 127.0.0.1    Database: nacos
-- ------------------------------------------------------
-- Server version	8.4.5

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `nacos`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `nacos` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `nacos`;

--
-- Table structure for table `config_info`
--

DROP TABLE IF EXISTS `config_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'group_id',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  `c_desc` varchar(256) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'configuration description',
  `c_use` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'configuration usage',
  `effect` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT '配置生效的描述',
  `type` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT '配置的类型',
  `c_schema` text COLLATE utf8mb3_bin COMMENT '配置的模式',
  `encrypted_data_key` varchar(1024) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT '密钥',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_info';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info`
--

LOCK TABLES `config_info` WRITE;
/*!40000 ALTER TABLE `config_info` DISABLE KEYS */;
INSERT INTO `config_info` (`id`, `data_id`, `group_id`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `app_name`, `tenant_id`, `c_desc`, `c_use`, `effect`, `type`, `c_schema`, `encrypted_data_key`) VALUES (5,'authorization-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','b283013226fc255404fcee0daaf427e1','2024-05-13 16:20:34','2025-06-30 02:01:24','fyy','192.168.65.1','authorization','7','鉴权中心基础配置-测试环境','','','yaml','',''),(7,'gateway-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          # 让gateway可以发现nacos中的微服务\n          enabled: true\n      # 全局的跨域处理\n      globalcors:\n        # 解决options请求被拦截问题\n        add-to-simple-url-handler-mapping: true\n        # 跨域配置\n        corsConfigurations:\n          \'[/**]\':\n            # 允许哪些网站的跨域请求\n            allowedOrigins:\n              - \"http://localhost:5173\"\n            # 允许的跨域ajax的请求方式\n            allowedMethods:\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            # 允许在请求中携带的头信息\n            allowedHeaders: \"*\"\n            # 是否允许携带cookie\n            allowCredentials: true\n            # 这次跨域检测的有效期\n            maxAge: 360000\n      # 路由\n      routes:\n        # 路由的名字-唯一\n        - id: build-member-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://member\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/member/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-authorization-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://authorization\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/authorization/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-capability-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://capability\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/capability/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-dictionary-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://dictionary\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/dictionary/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-data-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://data\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/data/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-message-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://message\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/message/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-builder-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://builder\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/builder/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n            \n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'*\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','018ca0bbe805f5d2ca56bb875c23c3ae','2024-05-13 19:31:19','2025-06-30 02:00:56','fyy','192.168.65.1','gateway','7','网关基础配置-测试环境','','','yaml','',''),(10,'jwt-test.yaml','system','# JWT 配置\njwt:\n  # 私钥\n  private-key: |\n    -----BEGIN PRIVATE KEY-----\n    MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDE4+6LTFPezLHIotaJ3Z0nIiDexOnlVJs+zFVs2YVKEj8RZLE91+4FO67lR/C3sQZj8BHTb0UPurDjWFyMt1HmxOty5R5XDgrrsUbBj1Wgn6ue2VzY0mXM0b/y8Kjmj2IaCQh5bzt2+n9YIBJbec7rObSeeipvw4wi5SdTiKRbWgLVmoUOvhoFXVrV9Hfo49S8mTQoBpmeUiO+/rjMew0QGFqARO2+5fWKo/mteHIjHu4J+mI3WDRl7mBaYCsv6EUsBZc/EGfvvEkNeuob+iI0b32rAPTgnHrCOVelPlHwUHr31eRh8Poh/k94cUBh9/U/8jVXzlQJcMFG0Jtc1aUzAgMBAAECggEALResvt9sx/amcvaEXw/P2bIRyCNeFCVD5uaCXAsXYUb7hb7DbxAAldc874sB4PgcqA/H7V4q+Xa+41qN27ZyfgE0kVxTDgoLyz4PH+51ZHOdKSTMBGZvZTDWnsuqSx+kjqTp+XHVsyKcvrCds7CaiLnvGWqORImLE0TbNGDzj24O8Ex4bcjpNa5POGLzco5JlLUJ4HbXf/89c6uS9V8dv2/ev+iRl4JqWFxEc8+0vyFt8rmz36Kf1CImB6D+GWV3Edt7roaHy6zI8A0NV3yz52ROvL/cdCNVljPZWKiOqVF0jrSbc4nlecOB5G9fb3UN2COabqHD2PqKuIUWEvnANQKBgQD8t3a2UsKwOofdO0CHivpvaNcXOpmwPkLVRSDC8QiE7WTaZtsmdXVibqOY1fCkGrpVLWGgwAchPa5prNNQ6o+w9u/7EGiDiBdI+mvoHNSw/eFErj74QJtX5SfZn4K9s8QWx6T9ygQ5+LLtUVyZuTqLiqKnmf4Xfrj/9etqO06vVQKBgQDHcsoodfqg92rrM7MY9a3nEjxx22kklDIKrAcjuto0LVm9n6D/L6ayBLfisgWdzTTDOdAeDE7oy2pI8TGBjFTYIqeXL0qztyP6sjUClZzCJmz2IsposOSzQgO6NDHOCnzJkMi6uSknWubYTuJw1W9aA3hbznCE8sk5uIeueTSyZwKBgErlmLI6XubZwfBoIhzJrKUeHjkNLgVUvnv0i9wakVrL/IrZ1vNT9mEgxy2BolsQbM7Xr0pz/uj0Hd/Fz674hXN+C+uNllv9FmGTji1xdfuqknvHZHQwuZlYGfJeWuIcB+50Zsqsd4oy0dyRs27/vYEjqkcf1XVjIjMB0C5gu1YtAoGAbQE1r4tbYSIYE1f8KEYNt15mHqwV+OHtv5tpg4OZwi6O/24A5bc7WcvuXD2DiE0g6xnrvqBneB/EhP0dW3pA3KeEBMLaBwKu7VL8Wd8+/3VU0+kLys/zDm2j796a4csljFxO+I4+Cb5KsCnc5GIiK4X9/98B7AdtJtjNfvPLcz0CgYBnZROtPfulFSIEXNwL5RMrGgiMBpSMIuXcKcdfGFvhtD9FaDb2j0Ba4GupmWIxPooYN8/XbjRN/E71mipjEEpLxIadJMjsAceR1GVLVEVAfFi3XB5hMZHuJgi6AVcrrCqw2wUPItjkw+X8ur3uRpap6FT4LchTpP2iJK9AgnxIIw==\n    -----END PRIVATE KEY-----\n  # 公钥\n  public-key: |\n    -----BEGIN PUBLIC KEY-----\n    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxOPui0xT3syxyKLWid2dJyIg3sTp5VSbPsxVbNmFShI/EWSxPdfuBTuu5Ufwt7EGY/AR029FD7qw41hcjLdR5sTrcuUeVw4K67FGwY9VoJ+rntlc2NJlzNG/8vCo5o9iGgkIeW87dvp/WCASW3nO6zm0nnoqb8OMIuUnU4ikW1oC1ZqFDr4aBV1a1fR36OPUvJk0KAaZnlIjvv64zHsNEBhagETtvuX1iqP5rXhyIx7uCfpiN1g0Ze5gWmArL+hFLAWXPxBn77xJDXrqG/oiNG99qwD04Jx6wjlXpT5R8FB699XkYfD6If5PeHFAYff1P/I1V85UCXDBRtCbXNWlMwIDAQAB\n    -----END PUBLIC KEY-----\n  # 有效期，单位毫秒秒\n  access-token-expire-time: PT2H\n  # 刷新过期时间\n  refresh-token-expire-time: PT8H\n  # APP刷新过期时间\n  refresh-token-expire-app-time: P30D\n  # JWT存储的请求头\n  token-header: Authorization\n  # JWT负载中拿到开头\n  token-head: Bearer\n  # 签发系统\n  issuer: authorization\n  # 是否输出相关日志\n  show-log: true','d9e1741ec25bd84c88726e6a6901f2dc','2024-06-24 15:06:27','2024-06-26 10:32:43','fyy','192.168.65.1','jwt','7','jwt认证配置-测试环境','','','yaml','',''),(13,'mail-test.yaml','system','#邮箱配置\nspring:\n  mail:\n    host: smtp.sina.cn\n    username: fuyongyuan277@sina.cn\n    password: d0afada3105a3a39\n    properties:\n      personal: \'哎呋歪歪平台\'','2d30a91297693c0d33cb1efe9dc45c82','2024-07-03 14:44:18','2024-07-03 14:44:18','fyy','192.168.65.1','mail','7','mail链接配置-测试环境',NULL,NULL,'yaml',NULL,''),(14,'minio-test.yaml','system','# 文件系统-来源于项目resources下的credentials.json\nminio:\n  # okhttp3 不能直接使用127.0.0.1所以使用localhost\n  url: http://localhost:10000\n  access-key: Fi0jJTQMwab11bPSLaxv\n  secret-key: BdWJcE4HwfTWJmLb73fIzPqY8Y9JA8eXnX57kL50\n  bucket-name: build','ad3d13e33da7963819d9ee130e93eb86','2024-07-03 15:55:48','2025-04-15 09:26:33','fyy','192.168.65.1','minio','7','minio链接配置-测试环境','','','yaml','',''),(15,'authorization-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.authorization.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.authorization.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.authorization.service.impl.*,cn.fyy.authorization.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','9c3e7a21a0918fd366452fd8eb057a32','2024-07-04 14:04:47','2025-06-26 08:05:05','fyy','192.168.65.1','authorization','7','mysql链接配置-测试环境','','','yaml','',''),(16,'redis-test.yaml','system','spring:\n  data:\n    redis:\n      # Redis服务器地址\n      host: 127.0.0.1\n      # Redis服务器连接端口\n      port: 6379\n      # Redis服务器连接密码（默认为空）\n      password: fyyain77\n      # Redis数据库索引（默认为0）\n      database: 0\n      # 连接空闲超过N(s秒、ms毫秒，不加单位时使用毫秒)后关闭，0为禁用，这里配置值和tcp-keepalive值一致\n      timeout: 60s\n      # Lettuce连接池配置\n      lettuce:\n        pool:\n          # 允许最大连接数，默认8（负值表示没有限制），推荐值：大于cpu * 2，通常为(cpu * 2) + 2\n          max-active: 10\n          # 最大空闲连接数，默认8，推荐值：cpu * 2\n          max-idle: 8\n          # 最小空闲连接数，默认0\n          min-idle: 0\n          # 连接用完时，新的请求等待时间(s秒、ms毫秒)，超过该时间抛出异常，默认-1（负值表示没有限制）\n          max-wait: 5s\n','bd96bb87818f8751b249830724cfd221','2024-07-04 15:09:51','2024-07-04 15:09:51','fyy','192.168.65.1','redis','7','redis链接配置-测试环境',NULL,NULL,'yaml',NULL,''),(17,'builder-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 15:20:22','2025-06-30 02:00:09','fyy','192.168.65.1','builder','7','构建模块基础配置-测试环境','','','yaml','',''),(18,'builder-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.builder.repository\'\n    # 数据模型目录\n    dbo-path: cn.fyy.builder.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.builder.service.impl.*,cn.fyy.builder.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','a0965b415ee08a81fefaf21f4e704db9','2024-07-04 15:24:22','2025-06-26 08:05:31','fyy','192.168.65.1','builder','7','mysql链接配置-测试环境','','','yaml','',''),(19,'capability-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 15:44:24','2025-06-30 01:59:50','fyy','192.168.65.1','capability','7','能力模块基础配置-测试环境','','','yaml','',''),(20,'capability-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.capability.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.capability.bean.dbo\'\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.capability.service.impl.*,cn.fyy.capability.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','e0f5d06bb2236e1afdf2566f179d9b80','2024-07-04 15:47:46','2025-06-26 08:05:54','fyy','192.168.65.1','capability','7','mysql链接配置-测试环境','','','yaml','',''),(21,'data-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  servlet:\n    multipart:\n      # 是否启用http上传处理\n      enabled: true\n      # 最大请求文件的大小\n      max-request-size: 100MB\n      # 设置单个文件最大长度\n      max-file-size: 20MB\n      # 当文件达到多少时进行磁盘写入\n      file-size-threshold: 20MB\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','f4e64c8a00b5bb01aa9070234a1a38f8','2024-07-04 15:57:53','2025-06-30 01:59:32','fyy','192.168.65.1','data','7','数据模块基础配置-测试环境','','','yaml','',''),(22,'dictionary-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 16:09:35','2025-06-30 01:59:15','fyy','192.168.65.1','dictionary','7','数据字典模块基础配置-测试环境','','','yaml','',''),(23,'dictionary-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.dictionary.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.dictionary.bean.dbo\'\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.dictionary.service.impl.*,cn.fyy.dictionary.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','e9ff02d687dc4b7468fc20e351ffa7ca','2024-07-04 16:12:37','2025-06-24 12:29:23','fyy','192.168.65.1','dictionary','7','mysql链接配置-测试环境','','','yaml','',''),(24,'member-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','b283013226fc255404fcee0daaf427e1','2024-07-04 16:24:20','2025-06-30 01:59:02','fyy','192.168.65.1','member','7','用户中心基础配置-测试环境','','','yaml','',''),(25,'member-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.member.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.member.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.member.service.impl.*,cn.fyy.member.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','3f5fa9d7c4cbcb40780db3f030dfe6c0','2024-07-04 16:27:07','2025-06-26 08:07:07','fyy','192.168.65.1','member','7','mysql链接配置-测试环境','','','yaml','',''),(26,'message-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2024-07-04 16:40:07','2025-06-30 01:58:38','fyy','192.168.65.1','message','7','消息中心基础配置-测试环境','','','yaml','',''),(27,'message-data-test.yaml','service','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.message.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.message.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.message.service.impl.*,cn.fyy.message.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','953d85d6fed256ad5d57fddb16a84c02','2024-07-04 16:41:57','2025-06-26 08:07:36','fyy','192.168.65.1','message','7','mysql链接配置-测试环境','','','yaml','',''),(28,'rocketmq-test.yaml','system','spring:\n  cloud:\n    # 两个 bindings 这种设计是为了分离 行为配置 和 主题绑定配置，使得配置更加清晰和灵活。\n    stream:\n      rocketmq:\n        binder:\n          # RocketMQ NameServer 地址\n          name-server: 127.0.0.1:9876\n        # 定义生产者和消费者的高级行为，-out-0是必须的，-out或-in是生产者或消费者，-0是一个标识\n        bindings:\n          # 生产者\n          share-out-0:\n            producer:\n              # 生产者分组\n              group: share_producer\n          # 消费者\n          share-in-0:\n            consumer:\n              # 消费者消费模式-集群模式\n              messageModel: CLUSTERING\n      # 定义消息通道与 RocketMQ 主题的绑定关系，需要与上方一致\n      bindings:\n        # 生产者\n        share-out-0:\n          # 主题\n          destination: share\n        # 消费者\n        share-in-0:\n          # 主题\n          destination: share\n          # 消费者分组\n          group: share_consumer\n','850f23027398b60ecce44cadc8736be0','2025-04-17 12:04:36','2025-04-28 09:12:02','fyy','192.168.65.1','rocketmq','7','rocketmq链接配置-测试环境','','','yaml','',''),(29,'mongodb-test.yaml','system','spring:\n  # mongodb 配置\n  data:\n    mongodb:\n      host: 127.0.0.1\n      port: 17017\n      username: fyy\n      password: fyyain77\n      database: test','1f096c1b8207b7eeddfef2ec3d112496','2025-05-04 09:12:10','2025-05-04 09:12:10','fyy','192.168.65.1','mongodb','7','rocketmq链接配置-测试环境',NULL,NULL,'yaml',NULL,''),(30,'elasticsearch-test.yaml','system','spring:\n  # elasticsearch 配置\n  elasticsearch:\n    rest:\n      # 根据实际情况修改地址和端口\n      uris: http://127.0.0.1:9200\n      # 用户名\n      username: elastic\n      # 密码\n      password: fyyain77','bc74e63918fd8228d50bc78639392ea6','2025-06-13 02:29:10','2025-06-13 02:30:17','fyy','192.168.65.1','elasticsearch','7','elasticsearch链接配置-测试环境','','','yaml','',''),(31,'seata-server-test.yaml','system','seata:\n  # 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\n  store:\n    mode: db\n    lock:\n      mode: db\n    session:\n      mode: db\n    # 用于密码加密\n    public-key:\n\n    # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n    db:\n      datasource: druid\n      # 数据库类型\n      db-type: mysql\n      # 连接驱动\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      # 数据库地址\n      url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n      # 数据库账号\n      user: root\n      # 数据库密码\n      password: fyyain77\n      min-conn: 5\n      max-conn: 30\n      query-limit: 100\n      max-wait: 5000\n      # 全局事务表\n      global-table: global_table\n      # 分支事务表\n      branch-table: branch_table\n      # 全局事务锁表\n      lock-table: lock_table\n      # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n      distributed-lock-table: distributed_lock','3a579669069e9a77038868057f03302e','2025-06-23 09:36:06','2025-06-24 09:29:10','fyy','192.168.65.1','seata','7','seata服务配置-测试环境','','','yaml','',''),(32,'job-base-test.yaml','service','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always','e49a62251d75da02bcf3168504651134','2025-06-27 12:25:53','2025-06-30 01:58:22','fyy','192.168.65.1','job','7','定时任务执行器基础配置-测试环境','','','yaml','',''),(33,'job-xxl-test.yaml','service','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: log/${spring.application.name}-handler-${spring.profiles.active}\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','6069cc039204971fe79a4dbc1b487589','2025-06-27 12:30:14','2025-06-27 13:15:16','fyy','192.168.65.1','job','7','定时任务执行器xxl链接配置-测试环境','','','yaml','','');
/*!40000 ALTER TABLE `config_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_info_aggr`
--

DROP TABLE IF EXISTS `config_info_aggr`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info_aggr` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `datum_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'datum_id',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT '内容',
  `gmt_modified` datetime NOT NULL COMMENT '修改时间',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='增加租户字段';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info_aggr`
--

LOCK TABLES `config_info_aggr` WRITE;
/*!40000 ALTER TABLE `config_info_aggr` DISABLE KEYS */;
/*!40000 ALTER TABLE `config_info_aggr` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_info_beta`
--

DROP TABLE IF EXISTS `config_info_beta`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info_beta` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `beta_ips` varchar(1024) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'betaIps',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  `encrypted_data_key` varchar(1024) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT '密钥',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_info_beta';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info_beta`
--

LOCK TABLES `config_info_beta` WRITE;
/*!40000 ALTER TABLE `config_info_beta` DISABLE KEYS */;
/*!40000 ALTER TABLE `config_info_beta` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_info_tag`
--

DROP TABLE IF EXISTS `config_info_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_info_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_id',
  `tag_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'tag_id',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_info_tag';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_info_tag`
--

LOCK TABLES `config_info_tag` WRITE;
/*!40000 ALTER TABLE `config_info_tag` DISABLE KEYS */;
/*!40000 ALTER TABLE `config_info_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `config_tags_relation`
--

DROP TABLE IF EXISTS `config_tags_relation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `config_tags_relation` (
  `id` bigint NOT NULL COMMENT 'id',
  `tag_name` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'tag_name',
  `tag_type` varchar(64) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'tag_type',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_id',
  `nid` bigint NOT NULL AUTO_INCREMENT COMMENT 'nid, 自增长标识',
  PRIMARY KEY (`nid`),
  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB AUTO_INCREMENT=146 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='config_tag_relation';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `config_tags_relation`
--

LOCK TABLES `config_tags_relation` WRITE;
/*!40000 ALTER TABLE `config_tags_relation` DISABLE KEYS */;
INSERT INTO `config_tags_relation` (`id`, `tag_name`, `tag_type`, `data_id`, `group_id`, `tenant_id`, `nid`) VALUES (10,'认证配置','','jwt-test.yaml','system','7',22),(13,'链接配置','','mail-test.yaml','system','7',26),(16,'链接配置','','redis-test.yaml','system','7',31),(14,'链接配置','','minio-test.yaml','system','7',86),(28,'链接配置','','rocketmq-test.yaml','system','7',114),(29,'链接配置','','mongodb-test.yaml','system','7',115),(30,'链接配置','','elasticsearch-test.yaml','system','7',117),(31,'服务配置','','seata-server-test.yaml','system','7',125),(23,'链接配置','','dictionary-data-test.yaml','service','7',127),(15,'链接配置','','authorization-data-test.yaml','service','7',128),(18,'链接配置','','builder-data-test.yaml','service','7',129),(20,'链接配置','','capability-data-test.yaml','service','7',130),(25,'链接配置','','member-data-test.yaml','service','7',131),(27,'链接配置','','message-data-test.yaml','service','7',132),(33,'链接配置','','job-xxl-test.yaml','service','7',136),(32,'基础配置','','job-base-test.yaml','service','7',137),(26,'基础配置','','message-base-test.yaml','service','7',138),(24,'基础配置','','member-base-test.yaml','service','7',139),(22,'基础配置','','dictionary-base-test.yaml','service','7',140),(21,'基础配置','','data-base-test.yaml','service','7',141),(19,'基础配置','','capability-base-test.yaml','service','7',142),(17,'基础配置','','builder-base-test.yaml','service','7',143),(7,'基础配置','','gateway-base-test.yaml','service','7',144),(5,'基础配置','','authorization-base-test.yaml','service','7',145);
/*!40000 ALTER TABLE `config_tags_relation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `group_capacity`
--

DROP TABLE IF EXISTS `group_capacity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `group_capacity` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群',
  `quota` int unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值',
  `max_aggr_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='集群、各Group容量信息表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `group_capacity`
--

LOCK TABLES `group_capacity` WRITE;
/*!40000 ALTER TABLE `group_capacity` DISABLE KEYS */;
/*!40000 ALTER TABLE `group_capacity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `his_config_info`
--

DROP TABLE IF EXISTS `his_config_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `his_config_info` (
  `id` bigint unsigned NOT NULL COMMENT 'id',
  `nid` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT 'nid, 自增标识',
  `data_id` varchar(255) COLLATE utf8mb3_bin NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'group_id',
  `app_name` varchar(128) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'app_name',
  `content` longtext COLLATE utf8mb3_bin NOT NULL COMMENT 'content',
  `md5` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `src_user` text COLLATE utf8mb3_bin COMMENT 'source user',
  `src_ip` varchar(50) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'source ip',
  `op_type` char(10) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'operation type',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT '租户字段',
  `encrypted_data_key` varchar(1024) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT '密钥',
  PRIMARY KEY (`nid`),
  KEY `idx_gmt_create` (`gmt_create`),
  KEY `idx_gmt_modified` (`gmt_modified`),
  KEY `idx_did` (`data_id`)
) ENGINE=InnoDB AUTO_INCREMENT=61 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='多租户改造';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `his_config_info`
--

LOCK TABLES `his_config_info` WRITE;
/*!40000 ALTER TABLE `his_config_info` DISABLE KEYS */;
INSERT INTO `his_config_info` (`id`, `nid`, `data_id`, `group_id`, `app_name`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `op_type`, `tenant_id`, `encrypted_data_key`) VALUES (0,31,'elasticsearch-test.yaml','system','elasticsearch','spring:\n  # elasticsearch 配置\n  elasticsearch:\n    rest:\n      # 根据实际情况修改地址和端口\n      uris: http://127.0.0.1:9200\n      # 如果启用了安全认证，请提供用户名\n      username: elastic\n      # 如果启用了安全认证，请提供密码\n      password: fyyain77','56674315d9ee05edd5f9646068d2b4a5','2025-06-13 02:29:10','2025-06-13 10:29:10','fyy','192.168.65.1','I','7',''),(30,32,'elasticsearch-test.yaml','system','elasticsearch','spring:\n  # elasticsearch 配置\n  elasticsearch:\n    rest:\n      # 根据实际情况修改地址和端口\n      uris: http://127.0.0.1:9200\n      # 如果启用了安全认证，请提供用户名\n      username: elastic\n      # 如果启用了安全认证，请提供密码\n      password: fyyain77','56674315d9ee05edd5f9646068d2b4a5','2025-06-13 02:30:16','2025-06-13 10:30:17','fyy','192.168.65.1','U','7',''),(0,33,'seata-server-test.yaml','system','seata','#Used for password encryption\nstore:\n  publicKey:\n','b66b17d7bedc3462f05412724bb207f4','2025-06-23 09:36:06','2025-06-23 17:36:06','fyy','192.168.65.1','I','7',''),(31,34,'seata-server-test.yaml','system','seata','#Used for password encryption\nstore:\n  publicKey:\n','b66b17d7bedc3462f05412724bb207f4','2025-06-23 09:46:16','2025-06-23 17:46:17','fyy','192.168.65.1','U','7',''),(31,35,'seata-server-test.yaml','system','seata','#事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  #用于密码加密\n  publicKey:\n\n  #如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: 123456\n    minConn: 5\n    maxConn: 30\n    globalTable: global_table\n    branchTable: branch_table\n    distributedLockTable: distributed_lock\n    queryLimit: 100\n    lockTable: lock_table\n    maxWait: 5000','759cf58a32a8482c36a8def0b98fed8d','2025-06-23 09:50:04','2025-06-23 17:50:04','fyy','192.168.65.1','U','7',''),(31,36,'seata-server-test.yaml','system','seata','#事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  #用于密码加密\n  publicKey:\n\n  #如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: fyyain77\n    minConn: 5\n    maxConn: 30\n    globalTable: global_table\n    branchTable: branch_table\n    distributedLockTable: distributed_lock\n    queryLimit: 100\n    lockTable: lock_table\n    maxWait: 5000','e9c9e9e735b3b8188e11079ec8600a12','2025-06-23 14:30:02','2025-06-23 22:30:02','fyy','192.168.65.1','U','7',''),(31,37,'seata-server-test.yaml','system','seata','#事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  #用于密码加密\n  publicKey:\n\n  #如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: fyyain77\n    minConn: 5\n    maxConn: 30\n    queryLimit: 100\n    maxWait: 5000\n    # 全局事务表\n    globalTable: global_table\n    # 分支事务表\n    branchTable: branch_table\n    # 全局事务锁表\n    lockTable: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributedLockTable: distributed_lock','89695a79a1c407777e41478b30d01d0e','2025-06-23 14:30:15','2025-06-23 22:30:15','fyy','192.168.65.1','U','7',''),(31,38,'seata-server-test.yaml','system','seata','# 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  # 用于密码加密\n  publicKey:\n\n  # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    dbType: mysql\n    driverClassName: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    user: root\n    password: fyyain77\n    minConn: 5\n    maxConn: 30\n    queryLimit: 100\n    maxWait: 5000\n    # 全局事务表\n    globalTable: global_table\n    # 分支事务表\n    branchTable: branch_table\n    # 全局事务锁表\n    lockTable: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributedLockTable: distributed_lock','b94053d7a09bab24be47312c8d691113','2025-06-24 07:45:18','2025-06-24 15:45:18','fyy','192.168.65.1','U','7',''),(31,39,'seata-server-test.yaml','system','seata','# 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  # 用于密码加密\n  publicKey:\n\n  # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    # 数据库类型\n    db-type: mysql\n    # 连接驱动\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    # 数据库地址\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    # 数据库账号\n    user: root\n    # 数据库密码\n    password: fyyain77\n    min-conn: 5\n    max-conn: 30\n    query-limit: 100\n    max-wait: 5000\n    # 全局事务表\n    globalTable: global_table\n    # 分支事务表\n    branchTable: branch_table\n    # 全局事务锁表\n    lockTable: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributedLockTable: distributed_lock','8472402753481aa2ef0fd56d90e01aaa','2025-06-24 07:55:40','2025-06-24 15:55:41','fyy','192.168.65.1','U','7',''),(31,40,'seata-server-test.yaml','system','seata','# 事务存储配置，仅用于服务器。file、db和redis的配置值是可选的。\nstore:\n  mode: db\n  lock:\n    mode: db\n  session:\n    mode: db\n  # 用于密码加密\n  public-key:\n\n  # 如果“存储模式”为“db”，则需要这些配置。如果“store.mode, store.lock.mode store.session。Mode ‘不等于’ db \'，您可以删除配置块。\n  db:\n    datasource: druid\n    # 数据库类型\n    db-type: mysql\n    # 连接驱动\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    # 数据库地址\n    url: jdbc:mysql://host.docker.internal:3306/seata?useUnicode=true&rewriteBatchedStatements=true\n    # 数据库账号\n    user: root\n    # 数据库密码\n    password: fyyain77\n    min-conn: 5\n    max-conn: 30\n    query-limit: 100\n    max-wait: 5000\n    # 全局事务表\n    global-table: global_table\n    # 分支事务表\n    branch-table: branch_table\n    # 全局事务锁表\n    lock-table: lock_table\n    # 分支事务锁表（多 Server 集群下保证同时只有一个 Server 处理提交或回滚）\n    distributed-lock-table: distributed_lock','ba18d612a1b63b19d58f8f2f40d7651f','2025-06-24 09:29:09','2025-06-24 17:29:10','fyy','192.168.65.1','U','7',''),(23,41,'dictionary-data-test.yaml','service','dictionary','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.dictionary.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.dictionary.bean.dbo\'\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.dictionary.service.impl.*,cn.fyy.dictionary.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','513f2a222b34197624a1dabd4652855c','2025-06-24 12:28:48','2025-06-24 20:28:48','fyy','192.168.65.1','U','7',''),(23,42,'dictionary-data-test.yaml','service','dictionary','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.dictionary.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.dictionary.bean.dbo\'\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.dictionary.service.impl.*,cn.fyy.dictionary.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/dictionary?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n# 分布式事务\nseata:\n  application-id: seata-${spring.application.name}-${spring.profiles.active}\n  registry:\n    type: nacos\n    nacos:\n      server-addr: ${spring.cloud.nacos.discovery.server-addr}\n      username: ${spring.cloud.nacos.discovery.username}\n      password: ${spring.cloud.nacos.discovery.password}\n      namespace: ${spring.cloud.nacos.discovery.namespace}\n      cluster-name: ${spring.cloud.nacos.discovery.cluster-name}\n      # 分组\n      group: system\n      # Nacos 中 Seata 名称\n      application: seata-server\n  # 事务组（被一个集群管理）\n  tx-service-group: seata_tx_group\n  service:\n    vgroup-mapping:\n      # 映射到默认的服务分组-名字同上\n      seata_tx_group: default\n  # 实现 AT 模式\n  data-source-proxy-mode: AT','7d92546b87098eed526850536ed87149','2025-06-24 12:29:22','2025-06-24 20:29:23','fyy','192.168.65.1','U','7',''),(15,43,'authorization-data-test.yaml','service','authorization','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.authorization.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.authorization.bean.dbo\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.authorization.service.impl.*,cn.fyy.authorization.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/authorization?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','768fe400852ddf710f330e2f7ebe45b8','2025-06-26 08:05:04','2025-06-26 16:05:05','fyy','192.168.65.1','U','7',''),(18,44,'builder-data-test.yaml','service','builder','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.builder.repository\'\n    # 数据模型目录\n    dbo-path: cn.fyy.builder.bean.dbo\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.builder.service.impl.*,cn.fyy.builder.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/builder?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','8356df9969343ab3f1014fba9eaae164','2025-06-26 08:05:30','2025-06-26 16:05:31','fyy','192.168.65.1','U','7',''),(20,45,'capability-data-test.yaml','service','capability','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: \'cn.fyy.capability.repository\'\n    # 数据模型目录\n    dbo-path: \'cn.fyy.capability.bean.dbo\'\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.capability.service.impl.*,cn.fyy.capability.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/capability?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','367ae7d6612345f71a41d5a49aa10ed9','2025-06-26 08:05:54','2025-06-26 16:05:54','fyy','192.168.65.1','U','7',''),(25,46,'member-data-test.yaml','service','member','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.member.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.member.bean.dbo\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.member.service.impl.*,cn.fyy.member.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/member?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','b507ba8e1e18de22b109fd22c42d0211','2025-06-26 08:07:07','2025-06-26 16:07:07','fyy','192.168.65.1','U','7',''),(27,47,'message-data-test.yaml','service','message','spring:\n  # JPA设置\n  jpa:\n    hibernate:\n      # 运行时对表得操作\n      # create 启动时删数据库中的表，然后创建，退出时不删除数据表\n      # create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错\n      # update 如果启动时表格式不一致则更新表，原有数据保留\n      # validate 项目启动表结构进行校验 如果不一致则报错\n      ddl-auto: update\n    # sql执行是否打印\n    show-sql: true\n    # 设置参数\n    properties:\n      hibernate:\n        # 格式化sql\n        format_sql: fales\n    # 打开视图\n    open-in-view: true\n    # 数据层目录\n    repository-path: cn.fyy.message.repository\n    # 数据模型目录\n    dbo-path: cn.fyy.message.bean.dbo\n\n\n  # 数据源配置\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 拦截器\n      web-stat-filter:\n        # 是否启用\n        enabled: true\n        # 经常需要排除一些不必要的url，比如*.js,/jslib/*等等\n        exclusions: \'*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\'\n        # 配置profileEnable能够监控单个url调用的sql列表\n        profile-enable: true\n        # 关闭session统计功能\n        session-stat-enable: false\n        # 拦截地址\n        url-pattern: /*\n      # 统计配置\n      stat-view-servlet:\n        # 是否启用\n        enabled: true\n        # 统计页面登录账号\n        login-password: fyy\n        # 统计页面登录密码\n        login-username: fyyain77\n        # 是否允许清空统计数据\n        reset-enable: false\n        # 访问地址\n        url-pattern: /druid/*\n        # 允许访问IP\n        allow:\n        # 拒绝访问IP\n        deny:\n      # AOP切面\n      aop-patterns: \'cn.fyy.message.service.impl.*,cn.fyy.message.repository.*\'\n      # 用户数据库读数据源\n      read:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 读取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: false\n              # 是否允许执行UPDATE语句\n              update-allow: false\n              # 是否允许执行INSERT语句\n              insert-allow: false\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: false\n              # 是否允许使用SET语法\n              set-allow: false\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: false\n              # 是否允许执行Alter Table语句\n              alter-table-allow: false\n              # 是否允许修改表\n              drop-table-allow: false\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: false\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: false\n              # 是否允许执行roll back操作\n              rollback-allow: false\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false\n\n      # 用户数据库写数据源\n      write:\n        # 连接驱动\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        # 数据库地址\n        url: jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&useSSL=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\n        # 数据库账号\n        username: root\n        # 数据库密码\n        password: fyyain77\n        # 初始化连接大小\n        initial-size: 10\n        # 连接最小数\n        min-idle: 10\n        # 连接最大数\n        max-active: 100\n        # 获取连接等待超时的时间\n        max-wait: 60000\n        # 启用连接池资源释放\n        keep-alive: true\n        # 用来检测连接是否有效的sql，要求是一个查询语句，常用select \'x\'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。\n        validation-query: select \'x\'\n        # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-borrow: false\n        # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n        test-on-return: false\n        # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n        test-while-idle: true\n        # 有两个含义：\n        #1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。\n        #2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n        time-between-eviction-runs-millis: 60000\n        # 连接保持空闲而不被驱逐的最小时间\n        min-evictable-idle-time-millis: 300000\n        # 连接泄漏监测 在内置监控页面weburi-detail.html中，查看JdbcPoolConnectionOpenCount和JdbcPoolConnectionCloseCount属性，如果不相等，就是泄漏了。\n        remove-abandoned: false\n        remove-abandoned-timeout: 1800\n        log-abandoned: true\n        # 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n        # 监控统计用的filter:stat\n        # 日志用的filter:log4j\n        # 防御sql注入的filter:wall\n        filters: stat,slf4j,wall\n        # 细致化配置\n        # 写取拦截sql配置\n        filter:\n          stat:\n            # 是否记录慢SQL\n            log-slow-sql: true\n            # 记录多慢的SQL，毫秒\n            slow-sql-millis: 3000\n            # 合并SQL\n            merge-sql: true\n          wall:\n            # 是否启用\n            enabled: true\n            # 数据库类型\n            db-type: mysql\n            # 对被认为是攻击的SQL进行LOG.error输出\n            log-violation: true\n            # 对被认为是攻击的SQL抛出SQLExcepton\n            throw-exception: true\n            # 拦截配置\n            config:\n              # 拦截语句\n              # 是否允许执行SELECT语句\n              selelct-allow: true\n              # 是否允许执行SELECT * FROM T这样的语句。如果设置为false，不允许执行select * from t，但select * from (select id, name from t) a。这个选项是防御程序通过调用select *获得数据表的结构信息。\n              select-all-column-allow: true\n              # SELECT查询中是否允许INTO字句\n              select-into-allow: false\n              # 是否允许执行DELETE语句\n              delete-allow: true\n              # 是否允许执行UPDATE语句\n              update-allow: true\n              # 是否允许执行INSERT语句\n              insert-allow: true\n              # 是否允许执行REPLACE语句\n              replace-allow: true\n              # 是否允许通过jdbc的call语法调用存储过程\n              call-allow: true\n              # 是否允许使用SET语法\n              set-allow: true\n              # truncate语句是危险(删除所有数据无法回滚)，缺省打开，若需要自行关闭\n              truncate-allow: false\n              # 是否允许创建表\n              create-table-allow: true\n              # 是否允许执行Alter Table语句\n              alter-table-allow: true\n              # 是否允许修改表\n              drop-table-allow: true\n              # 是否允许语句中存在注释，Oracle的用户不用担心，Wall能够识别hints和注释的区别\n              comment-allow: false\n              # 是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。\n              none-base-statement-allow: false\n              # 是否允许一次执行多条语句，缺省关闭\n              multi-statement-allow: true\n              # 是否允许执行mysql的use语句，缺省打开\n              use-allow: false\n              # 是否允许执行mysql的describe语句，缺省打开\n              describe-allow: false\n              # 是否允许执行mysql的show语句，缺省打开\n              show-allow: false\n              # 是否允许执行commit操作\n              commit-allow: true\n              # 是否允许执行roll back操作\n              rollback-allow: true\n              # 永真条件\n              # 检查SELECT语句的WHERE子句是否是一个永真条件\n              select-where-alway-true-check: true\n              # 检查SELECT语句的HAVING子句是否是一个永真条件\n              select-having-alway-true-check: true\n              # 检查DELETE语句的WHERE子句是否是一个永真条件\n              delete-where-alway-true-check: true\n              # 检查DELETE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              delete-where-none-check: true\n              # 检查UPDATE语句的WHERE子句是否是一个永真条件\n              update-where-alay-true-check: true\n              # 检查UPDATE语句是否无where条件，这是有风险的，但不是SQL注入类型的风险\n              update-where-none-check: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件\n              condition-and-alway-true-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件\n              condition-and-alway-false-allow: true\n              # 检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件\n              condition-like-true-allow: true\n              # 其他配置\n              # SELECT ... INTO OUTFILE 是否允许，这个是mysql注入攻击的常见手段，缺省是禁止的\n              select-into-outfile-allow: false\n              # 检测SELECT UNION\n              select-union-check: true\n              # 检测SELECT MINUS\n              select-minus-check: true\n              # 检测SELECT EXCEPT\n              select-except-check: true\n              # 检测SELECT INTERSECT\n              select-intersect-check: true\n              # 是否必须参数化，如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL\n              must-parameterized: false\n              # 是否进行严格的语法检测，Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错，可以临时把这个选项设置为false，同时把SQL反馈给Druid的开发者。\n              strict-syntax-check: true\n              # 查询条件中是否允许有XOR条件。XOR不常用，很难判断永真或者永假，缺省不允许。\n              condition-op-xor-allow: false\n              # 查询条件中是否允许有\"&\"、\"~\"、\"|\"、\"^\"运算符。\n              condition-op-bitwse-allow: true\n              # 查询条件中是否允许连续两个常量运算表达式\n              condition-double-const-allow: true\n              # 是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句\n              minus-allow: true\n              # 是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句\n              intersect-allow: true\n              # 拦截常量运算的条件，比如说WHERE FID = 3 - 1，其中\"3 - 1\"是常量运算表达式。\n              const-arithmetic-allow: true\n              # 是否允许limit 0这样的语句\n              limit-zero-allow: false\n              # 配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制\n              select-limit: -1\n              # 禁用对象检测配置\n              # 检测是否使用了禁用的表\n              table-check: true\n              # 检测是否使用了禁用的Schema\n              schema-check: true\n              # 检测是否使用了禁用的函数\n              function-check: true\n              # 检测是否使用了“禁用对对象”\n              object-check: true\n              # 检测是否使用了“禁用的变量”\n              variant-check: true\n              # 指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为\"被修改表\"出现<\n              read-only-tables:\n              # JDBC相关配置\n              # 是否允许调用Connection.getMetadata方法，这个方法调用会暴露数据库的表信息  false会导致报错但不影响功能使用\n              metadata-allow: true\n              # 是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法，这两个方法调用，使得有办法拿到原生驱动的对象，绕过WallFilter的检测直接执行SQL。\n              wrap-allow: false','7bdbbc3e83ef4eca438e79f50259bca3','2025-06-26 08:07:35','2025-06-26 16:07:36','fyy','192.168.65.1','U','7',''),(0,48,'job-base-test.yaml','service','job','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-27 12:25:52','2025-06-27 20:25:53','fyy','192.168.65.1','I','7',''),(0,49,'job-xxl-test.yaml','service','job','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: /data/applogs/xxl-job/jobhandler\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','d9c7394e9ee41bca3df3fec8ed2043a2','2025-06-27 12:30:14','2025-06-27 20:30:14','fyy','192.168.65.1','I','7',''),(33,50,'job-xxl-test.yaml','service','job','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: /data/applogs/xxl-job/jobhandler\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','d9c7394e9ee41bca3df3fec8ed2043a2','2025-06-27 13:10:40','2025-06-27 21:10:41','fyy','192.168.65.1','U','7',''),(33,51,'job-xxl-test.yaml','service','job','xxl:\n  job:\n    admin:\n      # 调度中心部署根地址 [必填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册；\n      addresses: http://127.0.0.1:10905/xxl-job-admin\n      # 调度中心通讯TOKEN [选填]：非空时启用；\n      accessToken: fyy\n      # 调度中心通讯超时时间[选填]，单位秒；默认3s；\n      timeout: 3\n    executor:\n      # 执行器AppName [必填]：执行器心跳注册分组依据；为空则关闭自动注册\n      appname: build-xxl-job-executor\n      # 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 \"IP:PORT\" 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。\n      address:\n      # 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯使用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"；\n      ip:\n      # 执行器端口号 [必填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；\n      port: 27999\n      # 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；\n      logpath: log/${spring.application.name}-job-handler-${spring.profiles.active}\n      # 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；\n      logretentiondays: 30','873ff87cb36661dacf0015422ab8de8c','2025-06-27 13:15:16','2025-06-27 21:15:16','fyy','192.168.65.1','U','7',''),(32,52,'job-base-test.yaml','service','job','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:58:22','2025-06-30 09:58:22','fyy','192.168.65.1','U','7',''),(26,53,'message-base-test.yaml','service','message','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:58:38','2025-06-30 09:58:38','fyy','192.168.65.1','U','7',''),(24,54,'member-base-test.yaml','service','member','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','2a25dcb649e1498d84d66419a7988eef','2025-06-30 01:59:02','2025-06-30 09:59:02','fyy','192.168.65.1','U','7',''),(22,55,'dictionary-base-test.yaml','service','dictionary','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:59:15','2025-06-30 09:59:15','fyy','192.168.65.1','U','7',''),(21,56,'data-base-test.yaml','service','data','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  servlet:\n    multipart:\n      # 是否启用http上传处理\n      enabled: true\n      # 最大请求文件的大小\n      max-request-size: 100MB\n      # 设置单个文件最大长度\n      max-file-size: 20MB\n      # 当文件达到多少时进行磁盘写入\n      file-size-threshold: 20MB\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','e28c82a3e65f91fda0101099bd6ed902','2025-06-30 01:59:31','2025-06-30 09:59:32','fyy','192.168.65.1','U','7',''),(19,57,'capability-base-test.yaml','service','capability','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 01:59:49','2025-06-30 09:59:50','fyy','192.168.65.1','U','7',''),(17,58,'builder-base-test.yaml','service','builder','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','47f0b63f9e6a38072b402808f723dbfc','2025-06-30 02:00:09','2025-06-30 10:00:09','fyy','192.168.65.1','U','7',''),(7,59,'gateway-base-test.yaml','service','gateway','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          # 让gateway可以发现nacos中的微服务\n          enabled: true\n      # 全局的跨域处理\n      globalcors:\n        # 解决options请求被拦截问题\n        add-to-simple-url-handler-mapping: true\n        # 跨域配置\n        corsConfigurations:\n          \'[/**]\':\n            # 允许哪些网站的跨域请求\n            allowedOrigins:\n              - \"http://localhost:5173\"\n            # 允许的跨域ajax的请求方式\n            allowedMethods:\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            # 允许在请求中携带的头信息\n            allowedHeaders: \"*\"\n            # 是否允许携带cookie\n            allowCredentials: true\n            # 这次跨域检测的有效期\n            maxAge: 360000\n      # 路由\n      routes:\n        # 路由的名字-唯一\n        - id: build-member-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://member\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/member/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-authorization-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://authorization\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/authorization/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-capability-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://capability\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/capability/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-dictionary-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://dictionary\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/dictionary/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-data-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://data\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/data/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-message-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://message\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/message/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n\n        # 路由的名字-唯一\n        - id: build-builder-route\n          # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略\n          uri: lb://builder\n          predicates:\n            # 符合这个规定的才进行1转发\n            - Path=/builder/**\n            # 这个时间之后可以访问\n            #- After=2037-01-20T17:42:47.789-07:00[Asia/Shanghai]\n          filters:\n            # 将第一层去掉\n            - StripPrefix=1\n            \n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'*\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log','a9c133d677900acfddcb1b7ce213ed42','2025-06-30 02:00:55','2025-06-30 10:00:56','fyy','192.168.65.1','U','7',''),(5,60,'authorization-base-test.yaml','service','authorization','spring:\n  jackson:\n    # 时间校准\n    time-zone: Asia/Shanghai\n    # 时间格式化\n    date-format: yyyy-MM-dd HH:mm:ss\n  thymeleaf:\n    # 不缓存前端\n    cache: false\n# 健康检查相关配置\nmanagement:\n  # 暴露内容配置\n  endpoints:\n    # web端点配置\n    web:\n      # 暴露内容配置\n      exposure:\n        # 确保健康检查端点被公开\n        include: \'health\'\n  # 返回内容配置\n  endpoint:\n    # 健康检查\n    health:\n      # 确保健康检查返回详细信息\n      show-details: always\n# 日志\nlogging:\n  file:\n    # 日志记录.默认10MB自动打包gz压缩包.从0号开始.\n    name: log/${spring.application.name}-${spring.profiles.active}.log\n# 鉴权\nauthorization:\n  # aes 密钥\n  aes-key: authorization-fyy','2a25dcb649e1498d84d66419a7988eef','2025-06-30 02:01:23','2025-06-30 10:01:24','fyy','192.168.65.1','U','7','');
/*!40000 ALTER TABLE `his_config_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `permissions`
--

DROP TABLE IF EXISTS `permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `permissions` (
  `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'role',
  `resource` varchar(128) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'resource',
  `action` varchar(8) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'action',
  UNIQUE KEY `uk_role_permission` (`role`,`resource`,`action`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `permissions`
--

LOCK TABLES `permissions` WRITE;
/*!40000 ALTER TABLE `permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `roles`
--

DROP TABLE IF EXISTS `roles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `roles` (
  `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'username',
  `role` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'role',
  UNIQUE KEY `idx_user_role` (`username`,`role`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `roles`
--

LOCK TABLES `roles` WRITE;
/*!40000 ALTER TABLE `roles` DISABLE KEYS */;
INSERT INTO `roles` (`username`, `role`) VALUES ('fyy','ROLE_ADMIN');
/*!40000 ALTER TABLE `roles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tenant_capacity`
--

DROP TABLE IF EXISTS `tenant_capacity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tenant_capacity` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin NOT NULL DEFAULT '' COMMENT 'Tenant ID',
  `quota` int unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数',
  `max_aggr_size` int unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='租户容量信息表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tenant_capacity`
--

LOCK TABLES `tenant_capacity` WRITE;
/*!40000 ALTER TABLE `tenant_capacity` DISABLE KEYS */;
/*!40000 ALTER TABLE `tenant_capacity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tenant_info`
--

DROP TABLE IF EXISTS `tenant_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tenant_info` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `kp` varchar(128) COLLATE utf8mb3_bin NOT NULL COMMENT 'kp',
  `tenant_id` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_id',
  `tenant_name` varchar(128) COLLATE utf8mb3_bin DEFAULT '' COMMENT 'tenant_name',
  `tenant_desc` varchar(256) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'tenant_desc',
  `create_source` varchar(32) COLLATE utf8mb3_bin DEFAULT NULL COMMENT 'create_source',
  `gmt_create` bigint NOT NULL COMMENT '创建时间',
  `gmt_modified` bigint NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 COLLATE=utf8mb3_bin COMMENT='tenant_info';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tenant_info`
--

LOCK TABLES `tenant_info` WRITE;
/*!40000 ALTER TABLE `tenant_info` DISABLE KEYS */;
INSERT INTO `tenant_info` (`id`, `kp`, `tenant_id`, `tenant_name`, `tenant_desc`, `create_source`, `gmt_create`, `gmt_modified`) VALUES (1,'1','7','build','集群','nacos',1715566617280,1720518414000);
/*!40000 ALTER TABLE `tenant_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `username` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'username',
  `password` varchar(500) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'password',
  `enabled` tinyint(1) NOT NULL COMMENT 'enabled',
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` (`username`, `password`, `enabled`) VALUES ('fyy','$2a$10$GOIX3LAsojczOiltrInyau2zTAtRnHQALKIY868AkPkC19Aj6Bs4W',1);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-07-25  6:53:23
